!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],t):"object"==typeof exports?exports.PhotogrammetricCamera=t(require("THREE")):e.PhotogrammetricCamera=t(e.THREE)}(window,(function(e){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="D:\\mbredif\\dev\\git\\github\\itownsResearch\\photogrammetric-camera\\dist",r(r.s=11)}([function(t,r){t.exports=e},function(e,t){e.exports='uniform float size;\r\nuniform float scale;\r\n#include <common>\r\n\r\n#ifdef USE_MAP4\r\nuniform vec3 uvwPosition;\r\nuniform mat4 uvwPreTransform;\r\nvarying highp vec4 vPosition;\r\n#undef USE_MAP\r\n#endif\r\n\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\nvoid main() {\r\n  #include <color_vertex>\r\n  #include <begin_vertex>\r\n  #include <morphtarget_vertex>\r\n  #include <project_vertex>\r\n  gl_PointSize = size;\r\n  #ifdef USE_SIZEATTENUATION\r\n    bool isPerspective = isPerspectiveMatrix( projectionMatrix );\r\n    if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n  #endif\r\n  #include <logdepthbuf_vertex>\r\n  #include <clipping_planes_vertex>\r\n  #include <worldpos_vertex>\r\n\r\n  #ifdef USE_MAP4\r\n    // "uvwPreTransform * m" is equal to "camera.preProjectionMatrix * camera.matrixWorldInverse * modelMatrix"\r\n    // but more stable when both the texturing and viewing cameras have large coordinate values\r\n    mat4 m = modelMatrix;\r\n    m[3].xyz -= uvwPosition;\r\n    vec4 uvw = uvwPreTransform * m * vec4(transformed, 1.);\r\n    vPosition = uvw;\r\n  #endif\r\n\r\n  #include <fog_vertex>\r\n}\r\n'},function(e,t){e.exports="uniform vec3 diffuse;\r\nuniform float opacity;\r\n#include <common>\r\n\r\nuniform bool diffuseColorGrey;\r\n#ifdef USE_MAP4\r\n#include <distortions/radial_pars_fragment>\r\nuniform mat4 uvwPostTransform;\r\nuniform RadialDistortion uvDistortion;\r\nuniform sampler2D map;\r\nuniform float borderSharpness;\r\nuniform float debugOpacity;\r\n\r\nvarying highp vec4 vPosition;\r\n#undef USE_MAP\r\n#endif\r\n\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n  #include <clipping_planes_fragment>\r\n  vec3 outgoingLight = vec3( 0.0 );\r\n  vec4 diffuseColor = vec4( diffuse, opacity );\r\n  #include <logdepthbuf_fragment>\r\n  #include <map_particle_fragment>\r\n  #include <color_fragment>\r\n\r\n  if (diffuseColorGrey) {\r\n    diffuseColor.rgb = vec3(dot(diffuseColor.rgb, vec3(0.333333)));\r\n  }\r\n  #ifdef USE_MAP4\r\n  vec4 uvw = vPosition;\r\n  if( uvw.w > 0. && distort_radial(uvw, uvDistortion))\r\n  {\r\n    uvw = uvwPostTransform * uvw;\r\n    uvw.xyz /= uvw.w;\r\n    vec3 border = min(uvw.xyz, 1. - uvw.xyz);\r\n    if (all(greaterThan(border,vec3(0.))))\r\n    {\r\n      vec4 color = texture2D(map, uvw.xy);\r\n      color.a *= min(1., borderSharpness*min(border.x, border.y));\r\n      diffuseColor.rgb = mix(diffuseColor.rgb, color.rgb, color.a);\r\n    } else {\r\n      diffuseColor.rgb = mix(diffuseColor.rgb, fract(uvw.xyz), debugOpacity);\r\n    }\r\n  }\r\n  #endif\r\n\r\n  #include <alphatest_fragment>\r\n  outgoingLight = diffuseColor.rgb;\r\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n  #include <tonemapping_fragment>\r\n  #include <encodings_fragment>\r\n  #include <fog_fragment>\r\n  #include <premultiplied_alpha_fragment>\r\n}\r\n"},function(e,t){e.exports="uniform float size;\r\n#ifdef USE_PROJECTIVE_TEXTURING\r\nuniform vec3 textureCameraPosition;\r\nuniform mat4 textureCameraPreTransform; // Contains the rotation and the intrinsics of the camera, but not the translation\r\nvarying vec4 vPosition;\r\nvarying float vDistanceCamera;\r\n#endif\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n    gl_PointSize = size;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n#ifdef USE_PROJECTIVE_TEXTURING\r\n    mat4 m = modelMatrix;\r\n    m[3].xyz -= textureCameraPosition;\r\n    vPosition = textureCameraPreTransform * m * vec4(position, 1.0);\r\n#endif\r\n    vColor = vec4(color, 1.);\r\n}\r\n"},function(e,t){e.exports="#include <distortions/radial_pars_fragment>\r\nuniform bool diffuseColorGrey;\r\n\r\n#ifdef USE_PROJECTIVE_TEXTURING\r\nuniform vec3 textureCameraPosition;\r\nuniform mat4 textureCameraPreTransform; // Contains the rotation and the intrinsics of the camera, but not the translation\r\nuniform mat4 textureCameraPostTransform;\r\nuniform RadialDistortion uvDistortion;\r\nuniform mat4 modelMatrix;\r\nvarying vec4 vPosition;\r\nuniform sampler2D map;\r\nuniform sampler2D depthMap;\r\n#endif\r\n\r\nvarying vec4 vColor;\r\n\r\nvoid main() {\r\n  vec4 finalColor = vColor;\r\n\r\n  if (diffuseColorGrey) {\r\n    finalColor.rgb = vec3(dot(vColor.rgb, vec3(0.333333)));\r\n  }\r\n\r\n#ifdef USE_PROJECTIVE_TEXTURING\r\n  // Project the point in the texture image\r\n  // p' = M' * (P - C')\r\n  // p': uvw\r\n  // M': textureCameraPreTransform\r\n  // P : vPositionWorld\r\n  // C': textureCameraPosition\r\n\r\n  vec4 uvw = vPosition;\r\n\r\n  // For the shadowMapping, which is not distorted\r\n  vec4 uvwNotDistorted = textureCameraPostTransform * uvw;\r\n  uvwNotDistorted.xyz /= uvwNotDistorted.w;\r\n\r\n  float minDist = texture2D(depthMap, uvwNotDistorted.xy).r;\r\n  float distanceCamera = uvwNotDistorted.z;\r\n\r\n  vec3 testBorderNotDistorted = min(uvwNotDistorted.xyz, 1. - uvwNotDistorted.xyz);\r\n\r\n  // ShadowMapping\r\n  if ( all(greaterThan(testBorderNotDistorted,vec3(0.))) && distanceCamera <= minDist + EPSILON ) {\r\n\r\n  // Don't texture if uvw.w < 0\r\n    if (uvw.w > 0. && distort_radial(uvw, uvDistortion)) {\r\n\r\n      uvw = textureCameraPostTransform * uvw;\r\n      uvw.xyz /= uvw.w;\r\n\r\n      // If coordinates are valid, they will be between 0 and 1 after normalization\r\n      // Test if coordinates are valid, so we can texture\r\n      vec3 testBorder = min(uvw.xyz, 1. - uvw.xyz);\r\n\r\n      if (all(greaterThan(testBorder,vec3(0.))))\r\n      {\r\n        vec4 color = texture2D(map, uvw.xy);\r\n        finalColor.rgb = mix(finalColor.rgb, color.rgb, color.a);\r\n      }\r\n    }\r\n  } else {\r\n    finalColor.rgb = vec3(0.2); // shadow color\r\n  }\r\n\r\n#endif\r\n\r\n  gl_FragColor =  finalColor;\r\n}\r\n"},function(e,t){e.exports="varying vec4 vPositionImage;\r\nuniform float size;\r\n\r\nvoid main() {\r\n\r\n    vPositionImage = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n    gl_Position = vPositionImage;\r\n\t\tgl_PointSize = size;\r\n\r\n}\r\n"},function(e,t){e.exports="varying vec4 vPositionImage;\r\n\r\nvoid main() {\r\n\r\n  float distanceCamera = ((vPositionImage.z / vPositionImage.w) + 1.) / 2.;\r\n  gl_FragColor = vec4(vec3(distanceCamera), 1.);\r\n\r\n}\r\n"},function(e,t){e.exports="// M^(-1) * screen -> this.viewProjectionScreenInverse\r\n// C -> uniform vec3 cameraPosition\r\n// M' -> this.textureCameraPostTransform * this.textureCameraPreTransform\r\n// C' -> this.textureCameraPosition\r\n// P -> attribute vec3 position;\r\n\r\nuniform float size;\r\nvarying vec4 vColor;\r\n\r\nuniform vec3 textureCameraPosition;\r\nuniform mat4 textureCameraPreTransform;\r\nuniform mat4 textureCameraPostTransform;\r\nuniform sampler2D depthMap;\r\nuniform vec3 E_prime;\r\nuniform mat3 M_prime_Pre;\r\nuniform mat3 viewProjectionScreenInverse;\r\nvarying mat3 vH;\r\nvarying float passShadowMapTest;\r\n\r\n\r\nvoid main() {\r\n    gl_PointSize = size;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n    vColor = vec4(color, 1.);\r\n\r\n\r\n    // Homography\r\n\r\n    vec4 P = modelMatrix * vec4( position, 1.0 );\r\n    P.xyz = P.xyz/P.w-cameraPosition;\r\n    vec3 N = P.xyz;\r\n    mat3 fraction = mat3(N.x*E_prime, N.y*E_prime, N.z*E_prime) / dot(N, P.xyz);\r\n    vH = (M_prime_Pre + fraction) * viewProjectionScreenInverse;\r\n\r\n\r\n    // ShadowMapping\r\n\r\n    mat4 m = modelMatrix;\r\n    m[3].xyz -= textureCameraPosition;\r\n    vec4 uvwNotDistorted = textureCameraPostTransform * textureCameraPreTransform * m * vec4(position, 1.0);\r\n    uvwNotDistorted.xyz /= uvwNotDistorted.w;\r\n\r\n    // If using ShadowMapMaterial:\r\n    // float minDist = unpackRGBAToDepth(texture2D(depthMap, uvwNotDistorted.xy));\r\n\r\n    float minDist = texture2D(depthMap, uvwNotDistorted.xy).r;\r\n    float distanceCamera = uvwNotDistorted.z;\r\n    vec3 testBorderNotDistorted = min(uvwNotDistorted.xyz, 1. - uvwNotDistorted.xyz);\r\n    if ( all(greaterThan(testBorderNotDistorted,vec3(0.))) && distanceCamera <= minDist + EPSILON ) {\r\n      passShadowMapTest = 1.0;\r\n    } else {\r\n      passShadowMapTest = 0.0;\r\n    }\r\n}\r\n"},function(e,t){e.exports="#include <distortions/radial_pars_fragment>\r\n\r\nuniform bool diffuseColorGrey;\r\nuniform sampler2D map;\r\nuniform RadialDistortion uvDistortion;\r\nuniform mat3 M_prime_Post;\r\nvarying mat3 vH;\r\nvarying vec4 vColor;\r\nvarying float passShadowMapTest;\r\n\r\nvoid main() {\r\n  vec4 finalColor = vColor;\r\n\r\n  if (diffuseColorGrey) {\r\n    finalColor.rgb = vec3(dot(vColor.rgb, vec3(0.333333)));\r\n  }\r\n\r\n  if (passShadowMapTest > 0.5) {\r\n\r\n    vec3 texCoord = vH * vec3(gl_FragCoord.xy, 1.);\r\n\r\n    // Don't texture if texCoord.z < 0 (z = w in this case)\r\n    if (texCoord.z > 0. && distort_radial_vec3(texCoord, uvDistortion)) {\r\n\r\n      texCoord = M_prime_Post * texCoord;\r\n      texCoord /= texCoord.z;\r\n\r\n      // Test if coordinates are valid, so we can texture\r\n      vec2 testBorder = min(texCoord.xy, 1. - texCoord.xy);\r\n\r\n      if (all(greaterThan(testBorder,vec2(0.))))\r\n      {\r\n        finalColor = texture2D(map, texCoord.xy);\r\n      } else {\r\n    \t   finalColor.rgb = vec3(0.2); // shadow color\r\n      }\r\n\r\n    } else {\r\n  \t   finalColor.rgb = vec3(0.2); // shadow color\r\n    }\r\n\r\n  } else {\r\n     finalColor.rgb = vec3(0.2); // shadow color\r\n  }\r\n\r\n  gl_FragColor =  finalColor;\r\n}\r\n"},function(e,t){e.exports="void fromRadial(const vec2 center, const vec2 resolution, const float pad, inout vec2 p) {\r\n  p.y *= 2.;\r\n  if(p.y>1.) {\r\n    p.y -= 1.;\r\n    p = ((resolution+2.*pad)*p-pad)/resolution;\r\n    float t = p.x < center.x ? p.x/center.x : (1.-p.x)/(1.-center.x) ;\r\n    p.y = mix(p.y, center.y, t);\r\n  } else {\r\n    p = ((resolution+2.*pad)*p-pad)/resolution;\r\n    float t = p.y < center.y ? p.y/center.y : (1.-p.y)/(1.-center.y) ;\r\n    p.x = mix(p.x, center.x, t);\r\n  }\r\n}\r\n\r\nvoid toRadial(const vec2 center, const vec2 resolution, const float pad, inout vec2 p) {\r\n  float t = p.y < center.y ? p.y/center.y : (1.-p.y)/(1.-center.y) ;\r\n  float u = p.x < center.x ? p.x/center.x : (1.-p.x)/(1.-center.x) ;\r\n  if(t>u) {\r\n    p.x -= 0.5/resolution.x;\r\n    p.y = mix(p.y, center.y, -u/(1.-u));\r\n    p = clamp(p, 0., 1.);\r\n    p = (resolution*p +pad)/(resolution+2.*pad);\r\n    p.y++;\r\n  } else {\r\n    p.y -= 0.5/resolution.y;\r\n    p.x = mix(p.x, center.x, -t/(1.-t));\r\n    p = clamp(p, 0., 1.);\r\n    p = (resolution*p +pad)/(resolution+2.*pad);\r\n  }\r\n  p.y *= 0.5;\r\n}\r\n"},function(e,t){e.exports="#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nin vec3 position;\r\nin vec2 uv;\r\nout vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4( position, 1.0 );\r\n}\r\n"},function(e,t,r){e.exports=r(12)},function(e,t,r){"use strict";r.r(t),r.d(t,"THREE_",(function(){return o})),r.d(t,"Serializers",(function(){return i})),r.d(t,"Parsers",(function(){return n})),r.d(t,"PhotogrammetricCamera",(function(){return l})),r.d(t,"FilesSource",(function(){return ce})),r.d(t,"FetchSource",(function(){return de})),r.d(t,"OrientedImageMaterial",(function(){return be})),r.d(t,"NewMaterial",(function(){return _e})),r.d(t,"ShadowMapMaterial",(function(){return Ne})),r.d(t,"SpriteMaterial",(function(){return Ve})),r.d(t,"RadialShader",(function(){return He})),r.d(t,"RadialBlurShader",(function(){return Be})),r.d(t,"SumShader",(function(){return Ye})),r.d(t,"RawShaderPass",(function(){return We}));var n={};r.r(n),r.d(n,"BundlerParser",(function(){return p})),r.d(n,"GeoJSONParser",(function(){return v})),r.d(n,"MatisParser",(function(){return b})),r.d(n,"MicmacParser",(function(){return L})),r.d(n,"OPKParser",(function(){return z}));var i={};r.r(i),r.d(i,"GeoJSONSerializer",(function(){return k})),r.d(i,"GMLSerializer",(function(){return j}));var o={};r.r(o),r.d(o,"OrbitControls",(function(){return I})),r.d(o,"MapControls",(function(){return H})),r.d(o,"FirstPersonControls",(function(){return q})),r.d(o,"PLYLoader",(function(){return G})),r.d(o,"CopyShader",(function(){return Z})),r.d(o,"EffectComposer",(function(){return ne})),r.d(o,"RenderPass",(function(){return oe})),r.d(o,"ShaderPass",(function(){return ee})),r.d(o,"WEBGL",(function(){return se}));var s=r(0);const a=(new s.Matrix4).set(2,0,0,-1,0,-2,0,1,0,0,1,0,0,0,0,1);s.Matrix4.prototype.lerp=function(e,t){var r=this.elements,n=e.elements;return r[0]+=t*(n[0]-r[0]),r[1]+=t*(n[1]-r[1]),r[2]+=t*(n[2]-r[2]),r[3]+=t*(n[3]-r[3]),r[4]+=t*(n[4]-r[4]),r[5]+=t*(n[5]-r[5]),r[6]+=t*(n[6]-r[6]),r[7]+=t*(n[7]-r[7]),r[8]+=t*(n[8]-r[8]),r[9]+=t*(n[9]-r[9]),r[10]+=t*(n[10]-r[10]),r[11]+=t*(n[11]-r[11]),r[12]+=t*(n[12]-r[12]),r[13]+=t*(n[13]-r[13]),r[14]+=t*(n[14]-r[14]),r[15]+=t*(n[15]-r[15]),this};class c extends s.PerspectiveCamera{constructor(e,t,r,n,i,o,a,c,l,u){e=Array.isArray(e)?(new s.Vector2).fromArray(e):e||1024,r=Array.isArray(r)?(new s.Vector2).fromArray(r):r,t=Array.isArray(t)?(new s.Vector2).fromArray(t):t||1024,e=e.isVector2?e:new s.Vector2(e,e),t=t.isVector2?t:new s.Vector2(t,t),n=n||0,r=r||t.clone().multiplyScalar(.5),super(void 0,c=c||t.x/t.y,o,a),Object.defineProperty(this,"fov",{get:()=>360*Math.atan2(this.view.fullHeight,2*this.focal.y)/Math.PI,set:e=>{var t=.5*this.view.fullHeight/Math.tan(e*Math.PI/360);this.focal.x=t,this.focal.y=t}}),this.isPhotogrammetricCamera=!0,this.focal=e,this.point=r,this.skew=n,this.distos=i||[],this.zoom=1,this.view={enabled:!1,offsetX:0,offsetY:0,width:t.x,height:t.y,fullWidth:t.x,fullHeight:t.y},this.filmOffset=0,this.mask=u,this.preProjectionMatrix=new s.Matrix4,this.postProjectionMatrix=new s.Matrix4,this.textureMatrix=new s.Matrix4,this.imageMatrix=l?(new s.Matrix4).copy(l):(new s.Matrix4).identity(),this.updateProjectionMatrix()}updateProjectionMatrix(){if(!this.preProjectionMatrix)return void super.updateProjectionMatrix();const e=-(this.far+this.near)/(this.far-this.near),t=-2*this.far*this.near/(this.far-this.near);this.preProjectionMatrix.set(this.focal.x,-this.skew,-this.point.x,0,0,-this.focal.y,-this.point.y,0,0,0,e,t,0,0,-1,0),this.textureMatrix.makeScale(1/this.view.fullWidth,1/this.view.fullHeight,1),this.imageMatrix&&this.textureMatrix.multiply(this.imageMatrix);var r=this.view.fullWidth/this.view.fullHeight;if(this.view.enabled){r=this.view.width/this.view.height;var n=this.view.fullWidth/this.view.width,i=this.view.fullHeight/this.view.height,o=this.view.offsetX/this.view.width,c=this.view.offsetY/this.view.height;this.textureMatrix.premultiply((new s.Matrix4).set(n,0,0,-o,0,i,0,-c,0,0,1,0,0,0,0,1))}var l=this.aspect/r,u=new s.Vector2(this.zoom,this.zoom);return l>1?u.x/=l:u.y*=l,this.postProjectionMatrix.makeScale(u.x,u.y,1),this.postProjectionMatrix.multiply(a),this.postProjectionMatrix.multiply(this.textureMatrix),this.projectionMatrix.multiplyMatrices(this.postProjectionMatrix,this.preProjectionMatrix),this}distort(e){return e.applyMatrix4(this.matrixWorldInverse),e.applyMatrix4(this.preProjectionMatrix),e=this.distos.reduce((e,t)=>t.project(e),e)}texture(e){return this.distort(e),e.applyMatrix4(this.textureMatrix),e}project(e){return this.distort(e),e.applyMatrix4(this.postProjectionMatrix),e}copy(e,t){return this==e?this:(super.copy(e,t),this.set(e))}getEffectiveFOV(){return 360*Math.atan2(this.view.fullHeight,2*this.focal.y*this.zoom)/Math.PI}getFocalLength(){return this.focal.y*this.getFilmHeight()/this.view.fullHeight}setFocalLength(e){return e*=this.view.fullHeight/this.getFilmHeight(),this.focal.x=e,this.focal.y=e,this.updateProjectionMatrix()}lerp(e,t){return this.focal.lerp(e.focal,t),this.point.lerp(e.point,t),this.position.lerp(e.position,t),this.quaternion.slerp(e.quaternion,t),this.skew+=t*(e.skew-this.skew),this.zoom+=t*(e.zoom-this.zoom),this.aspect+=t*(e.aspect-this.aspect),this.near+=t*(e.near-this.near),this.far+=t*(e.far-this.far),this.view.offsetX+=t*(e.view.offsetX-this.view.offsetX),this.view.offsetY+=t*(e.view.offsetY-this.view.offsetY),this.view.width+=t*(e.view.width-this.view.width),this.view.height+=t*(e.view.height-this.view.height),this.view.fullWidth+=t*(e.view.fullWidth-this.view.fullWidth),this.view.fullHeight+=t*(e.view.fullHeight-this.view.fullHeight),this.updateProjectionMatrix()}set(e){return this.name=e.name,this.focal.copy(e.focal),this.point.copy(e.point),this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.distos=e.distos.slice(0),this.skew=e.skew,this.zoom=e.zoom,this.aspect=e.aspect,this.near=e.near,this.far=e.far,Object.assign(this.view,e.view),this.updateProjectionMatrix()}}var l=c;var u={polynom:function(e,t){for(var r=e[e.length-1],n=e.length-2;n>=0;--n)r=r*t+e[n];return r},polynomVector3:function(e,t){return e.x+t*(e.y+t*e.z)}};function h(e,t,r,n){if(0==e)return function(e,t,r){var n=t*t-4*e*r;if(n<0)return[];var i=-t/(2*e);if(0==n)return[i];var o=Math.sqrt(n)/(2*e);return[i-o,i+o]}(t,r,n);var i=-t/(3*e),o=e*e,s=t*t,a=r/e-s/(3*o),c=t*s/(13.5*(e*o))+n/e-t*r/(3*o);if(0==a){var l=d(-c)+i;return[l,l,l]}var u=a*a*a*4/27,h=c*c+u;if(h>0){var m=Math.sqrt(h);return[d((-c+m)/2)+d((-c-m)/2)+i]}if(0==h){var f=3*c/a,p=i-.5*f;return[i+f,p,p]}var v=Math.acos(-c/Math.sqrt(u)),g=2*Math.sqrt(-a/3);return[i+g*Math.cos(v/3),i+g*Math.cos((v+Math.PI)/3),i+g*Math.cos((v+2*Math.PI)/3)]}function d(e){return function(e){return(e>0)-(e<0)}(e)*Math.pow(Math.abs(e),1/3)}s.ShaderChunk["distortions/radial_pars_fragment"]="\nstruct RadialDistortion {\n  vec2 C;\n  vec4 R;\n};\n\nbool distort_radial(inout vec4 p, RadialDistortion disto) {\n  p /= p.w;\n  vec2 r = p.xy - disto.C;\n  float r2 = dot(r, r);\n  if (r2 > disto.R.w) return false; // to be culled\n  float r4 = r2*r2;\n  p.xy += dot(disto.R.xyz, vec3(r2, r4, r2*r4)) * r;\n  return true;\n}\n\nbool distort_radial_vec3(inout vec3 p, RadialDistortion disto) {\n  p /= p.z;\n  vec2 r = p.xy - disto.C;\n  float r2 = dot(r, r);\n  if (r2 > disto.R.w) return false; // to be culled\n  float r4 = r2*r2;\n  p.xy += dot(disto.R.xyz, vec3(r2, r4, r2*r4)) * r;\n  return true;\n}\n";var m=class{constructor(e,t,r){t.length>3&&console.warn("RadialDistortion is currently limited to degrees 3,5,7: Neglecting higher order coefficients."),t[1]=t[1]||0,t[2]=t[2]||0,t[3]=r||function(e){var t=h(7*e[2],5*e[1],3*e[0],1),r=-1;for(var n in t)t[n]>0&&(-1==r||t[r]>t[n])&&(r=n);return-1==r?1/0:t[r]}(t),this.C=Array.isArray(e)?(new s.Vector2).fromArray(e):e,this.R=(new s.Vector4).fromArray(t),this.isRadialDistortion=!0}project(e){var t=e.x-this.C.x,r=e.y-this.C.y,n=t*t+r*r,i=n*u.polynomVector3(this.R,n);return e.x+=i*t,e.y+=i*r,e}};class f{static parse(e){const t=f.parseList(e[0]);return f.parseOut(e[1],t)}static parseList(e){const t=e.split(/\n/).map(e=>e.trim().split(/\s+/)),r=[],n=[];for(var i=0;i<t.length;++i)r[i]=t[i][0],n[i]=[Number(t[i][1]),Number(t[i][2])];return{names:r,sizes:n}}static parseOut(e,t){if(!e.startsWith("# Bundle file v0.3"))return null;const r=e.split(/\n/).map(e=>e.trim().split(/\s+/).map(Number)),n=r[1][0],i=r[1][1],o=[];for(var a=0;a<n;++a){const e=2+5*a,n=r[e][0],i=r[e][1],c=r[e][2],u=r[e+1],h=r[e+2],d=r[e+3],f=r[e+4],p=t.sizes[a],v=(new s.Vector2).fromArray(p).multiplyScalar(.5),g=n*n,w=new m(v,[i/g,c/(g*g),0]),x=new l(n,p,v,0,[w]);x.name=t.names[a],x.matrix.set(u[0],h[0],d[0],0,u[1],h[1],d[1],0,u[2],h[2],d[2],0,0,0,0,1),x.position.fromArray(f),x.position.applyMatrix4(x.matrix).negate(),x.matrix.setPosition(x.position),x.quaternion.setFromRotationMatrix(x.matrix),x.near=.1,x.far=1e3,x.updateMatrixWorld(!0),o.push(x),x.check=function(e,t){return e=e||this.check.epsilon,(t?this.check.points.slice(0,t):this.check.points).reduce((t,r)=>{var n=this.distort(r.p3.clone()),i=r.p2.distanceTo(n);return i>e&&(t=!1,console.warn(r.id,i,n,r.p2,r.p3)),t},!0)},x.check.epsilon=2,x.check.points=[]}const c=new Float32Array(3*i),u=new Uint8Array(3*i);for(var h=0;h<i;++h){const e=3*h,t=2+5*n+e,i=r[t],a=r[t+1],l=r[t+2];c.set(i,e),u.set(a,e);const m=(new s.Vector3).fromArray(i),f=l[0];for(var d=0;d<f;++d){if(l[1+4*d]>=o.length)continue;const e=o[l[1+4*d]],t=(new s.Vector2).fromArray(l,3+4*d);t.add(e.point),t.y=e.view.fullHeight-t.y,e.check.points.push({id:h+"/"+d,p2:t,p3:m})}}return o.points=c,o.colors=u,o}}f.format="Bundler/orientation",f.extensions=["out"],f.mimetypes=["application/text"],f.fetchtype="text";var p=f,v={parseFeature:function(e){const t=e.geometry.coordinates,r=e.properties,n=r.name;r.epsgquaternion,r.source;var i=[r.fx,r.fy],o=[r.sx,r.sy],s=[r.px,r.py],a=[r.cx,r.cy],c=[r.c3,r.c5,r.c7],u=[new m(a,c,r.cm)],h=new THREE.Matrix4;null!=r.m00&&(h.elements[0]=r.m00,h.elements[1]=r.m01,h.elements[4]=r.m10,h.elements[5]=r.m11,h.elements[12]=r.m20,h.elements[13]=r.m21);var d=new l(i,o,s,0,u,void 0,void 0,void 0,h);d.name=n;const f=new THREE.Vector3(t[0],t[1],t[2]),p=new THREE.Quaternion(r.qx,r.qy,r.qz,r.qw);return d.position.copy(f),d.quaternion.copy(p),d.userData.properties=r,d},parse:function(e){const t=[];try{const n=JSON.parse(e);for(var r of n.features)t.push(this.parseFeature(r));return t}catch(e){return null}},format:"GEOJSON/orientation",extensions:["json","geojson"],mimetypes:["application/text"],fetchtype:"text"};function g(e,t){var r=e.getElementsByTagName(t)[0];return r&&r.childNodes[0].nodeValue.trim()}function w(e,t){return Number(g(e,t))}function x(e,t,r){var n=e.getElementsByTagName(t)[0];return r.map(e=>w(n,e))}function y(e){var t=x(e,"image_size",["width","height"]),r=e.getElementsByTagName("spherique")[0];if(r)return function(e,t){var r=new s.Camera;return r.lambdaphi=x(e,"frame",["lambda_min","lambda_max","phi_min","phi_max"]),r.view.fullHeight=718,r.lambdaphi[2]=r.lambdaphi[3]-r.view.fullHeight*(r.lambdaphi[1]-r.lambdaphi[0])/r.view.fullWidth,r.projectionMatrix=(new s.Matrix4).set(r.view.fullWidth,0,.5*r.view.fullWidth,0,0,r.view.fullHeight,.5*r.view.fullHeight,0,0,0,0,1,0,0,1,0),r}(r);var n=e.getElementsByTagName("sensor")[0];if(n)return function(e,t){var r=w(e,"focale"),n=x(e,"ppa",["c","l"]),i=new m(x(e,"pps",["c","l"]),x(e,"distortion",["r3","r5","r7"])),o=.035*r[0]/t[0];return new l(r,t,n,0,[i],o,1e3)}(n,t);throw new Error("error parsing matis orientation")}var b={parse:function(e,t,r){if(e instanceof Node||(e=(new window.DOMParser).parseFromString(e,"text/xml")),"orientation"===e.children[0].tagName){var n=y(e);return n.matrix=function(e){var t=(e=e.getElementsByTagName("extrinseque")[0]).getElementsByTagName("mat3d")[0],r=new s.Matrix4;if(t){var n=x(t,"l1",["x","y","z"]),i=x(t,"l2",["x","y","z"]),o=x(t,"l3",["x","y","z"]);r.set(n[0],n[1],n[2],0,i[0],i[1],i[2],0,o[0],o[1],o[2],0,0,0,0,1)}else{var a=x(e,"quaternion",["x","y","z","w"]);r.makeRotationFromQuaternion((new s.Quaternion).fromArray(a))}return g(e,"Image2Ground")||r.transpose(),r.elements[12]=w(e,"easting"),r.elements[13]=w(e,"northing"),r.elements[14]=w(e,"altitude"),r.scale(new s.Vector3(1,-1,-1)),r}(e),n.matrix.decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0),n.name=r,n}},format:"matis/orientation",extensions:["xml"],mimetypes:["application/xml"],fetchtype:"xml"};var M=class{constructor(e,t){this.F=e,this.P=t,this.isBrownDistortion=!0}project(e){var t=e.x,r=e.y,n=t*t,i=r*r,o=t*r,s=t*i,a=r*n,c=n*i,l=this.P,u=l[12]*c/this.F+l[13]*(n+i);return e.x+=l[0]*t+l[1]*r,e.x+=l[2]*o+l[3]*i+l[4]*a+l[5]*s+l[6]*c+u*t,e.y+=l[7]*o+l[8]*n+l[9]*a+l[10]*s+l[11]*c+u*r,e}};var C=class{constructor(e,t,r,n,i,o){this.P=e,this.C=t,this.F=r,this.l=n,this.R=i,this.equisolid=o,this.isFishEyeDistortion=!0}project(e){var t=(e.x-this.C[0])/this.F,r=(e.y-this.C[1])/this.F,n=Math.sqrt(t*t+r*r),i=Math.atan(n);this.equisolid&&(i=2*Math.sin(.5*i));var o=i/n,s=o*t,a=o*r,c=s*s,l=s*a,h=a*a,d=c+h,m=1+d*u.polynom(this.R,d);e.x=a*this.l[1]+s*(m+this.l[0]),e.y=s*this.l[1]+a*m;for(var f=1,p=0;p<this.P.length;p+=2){var v=p+2;e.x+=f*((d+v*c)*this.P[p]+this.P[p+1]*v*l),e.y+=f*((d+v*h)*this.P[p+1]+this.P[p]*v*l),f*=d}for(var g=[c,l,h],w=2,x=3;w<this.l.length;++x){g[x]=a*g[x-1],g[0]*=s,e.y+=this.l[w++]*g[0];for(var y=1;y<x;++y)g[y]*=s,e.x+=this.l[w++]*g[y],e.y+=this.l[w++]*g[y];e.x+=this.l[w++]*g[x],x%2&&(e.y+=this.l[w++]*g[x])}return e.x=this.C[0]+this.F*e.x,e.y=this.C[1]+this.F*e.y,e}};var P=class{constructor(e,t,r,n){this.C=e,this.P=t,this.R=r,this.b=n,this.isFraserDistortion=!0}project(e){var t=e.x-this.C[0],r=e.y-this.C[1],n=t*t,i=r*r,o=t*r,s=n+i,a=s*u.polynom(this.R,s);return e.x+=a*t+this.P[0]*(2*n+s)+2*this.P[1]*o,e.y+=a*r+this.P[1]*(2*i+s)+2*this.P[0]*o,e.x+=this.b[0]*t+this.b[1]*r,e}};var E=class{constructor(e,t,r,n){if(!n){const e=r.length,t=Math.sqrt(25+4*e);n=Math.ceil(.5*t-1.5),r.length=n*(n+3)-4,r.fill(0,e)}var i=r.length-r.reverse().findIndex(e=>0!==e);r.reverse();for(var o=n-1;o>0;--o){var s=o*(o+3)-4;i<=s&&(r=r.slice(0,s),n=o)}this.C=e,this.S=t,this.R=r,this.degree=n,this.isPolynomDistortion=!0}project(e){e.x=(e.x-this.C[0])/this.S,e.y=(e.y-this.C[1])/this.S;var t=this.R,r=e.x,n=e.y,i=[r*r,r*n,n*n];e.x+=t[0]*r+t[1]*n+t[3]*i[1]-2*t[2]*i[0]+t[4]*i[2],e.y+=t[1]*r-t[0]*n+t[2]*i[1]-2*t[3]*i[2]+t[5]*i[0];for(var o=6,s=3;o<t.length;++s){var a=o+s+1;i[s]=n*i[s-1];for(var c=0;c<s;++c)i[c]*=r,e.x+=t[o+c]*i[c],e.y+=t[a+c]*i[c];e.x+=t[o+s]*i[s],e.y+=t[a+s]*i[s],o=a+s+1}return e.x=this.C[0]+this.S*e.x,e.y=this.C[1]+this.S*e.y,e}};function T(e,t){var r=e.getElementsByTagName(t)[0];return r&&r.childNodes[0].nodeValue.trim()}function _(e,t,r){var n=T(e,t);return n?n.split(" ").filter(String).map(Number):r}function S(e,t,r){return(new s.Vector2).fromArray(_(e,t,r))}function D(e,t,r){return(new s.Vector3).fromArray(_(e,t,r))}function R(e,t){return Array.from(e.getElementsByTagName(t)).map(e=>Number(e.childNodes[0].nodeValue))}function A(e){var t,r,n=(e=e.children[0]).tagName;switch("ModUnif"===n&&(n=T(e,"TypeModele"),t=R(e,"Params"),r=R(e,"Etats")),n){case"ModNoDist":return;case"eModeleEbner":return new Ebner(r[0],t);case"eModeleDCBrown":return new M(r[0],t);case"ModRad":{const t=R(e,"CoeffDist");if(0==t.length)return;const r=S(e,"CDist");return new m(r,t)}case"eModelePolyDeg2":case"eModelePolyDeg3":case"eModelePolyDeg4":case"eModelePolyDeg5":case"eModelePolyDeg6":case"eModelePolyDeg7":{const e=r[0],i=r.slice(1,3),o=Number(n.substr("eModelePolyDeg".length));return new E(i,e,t,o)}case"ModPhgrStd":{const t=_(e,"CDist"),r=R(e,"CoeffDist"),n=_(e,"P1",[0]).concat(_(e,"P2",[0])),i=_(e,"b1",[0]).concat(_(e,"b2",[0]));return new P(t,n,r,i)}case"eModele_FishEye_10_5_5":case"eModele_EquiSolid_FishEye_10_5_5":{const e="eModele_EquiSolid_FishEye_10_5_5"===n,i=r[0],o=t.slice(0,2),s=t.slice(2,12),a=t.slice(12,22),c=t.slice(22);return new C(a,o,i,c,s,e)}default:throw new Error("Error parsing micmac orientation : unknown distortion "+e.tagName)}}function O(e){var t=T(e,"KnownConv");if(t){var r=Math.PI/180,n=Math.PI/200,i=[1,1,1];switch(t){case"eConvApero_DistM2C":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!0,col:[1,1,1],scale:r,order:"ZYX"};case"eConvApero_DistC2M":return{Cardan:!0,lin:i,Video:!0,DistC2M:!0,MatrC2M:!0,col:[1,1,1],scale:r,order:"ZYX"};case"eConvOriLib":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!0,col:[1,1,1],scale:r,order:"XYZ"};case"eConvMatrPoivillier_E":return{Cardan:!0,lin:i,Video:!1,DistC2M:!1,MatrC2M:!1,col:[1,-1,-1],scale:r,order:"XYZ"};case"eConvAngErdas":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!1,col:[1,-1,-1],scale:r,order:"XYZ"};case"eConvAngErdas_Grade":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!1,col:[1,-1,-1],scale:n,order:"XYZ"};case"eConvAngPhotoMDegre":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!0,col:[1,-1,-1],scale:r,order:"XYZ"};case"eConvAngPhotoMGrade":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!0,col:[1,-1,-1],scale:n,order:"XYZ"};case"eConvMatrixInpho":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!1,col:[1,-1,-1],scale:void 0,order:"XYZ"};case"eConvAngLPSDegre":return{Cardan:!0,lin:i,Video:!0,DistC2M:!1,MatrC2M:!0,col:[1,-1,-1],scale:r,order:"YXZ"};default:throw new Error("Error parsing micmac orientation : unknown rotation convention : "+t)}}}function N(e,t,r){var n=function(e,t){if(!e)throw new Error("Error parsing micmac orientation, no intrinsics");e instanceof Node||(e=(new window.DOMParser).parseFromString(e,"text/xml"));var r=T(e,"KnownConv");if("eConvApero_DistM2C"!==r)throw new Error("Error parsing micmac orientation : unknown convention "+r);var n=S(e,"F"),i=S(e,"PP"),o=S(e,"SzIm"),s=_(e,"RayonUtile",[])[0];n.y=n.y||n.x;var a=Array.from(e.getElementsByTagName("CalibDistortion")).map(A).filter(e=>e).reverse(),c=.035*n.x/o.x,l=new PhotogrammetricCamera(n,o,i,0,a,c,1e3,void 0,t);return s&&(l.r2max=s*s),l}(r,function(e){if(!(e=e.getElementsByTagName("OrIntImaM2C")[0]))return null;var t=S(e,"I00"),r=S(e,"V10"),n=S(e,"V01");return 0!==t.x||0!==t.y||1!==r.x||0!==r.y||0!==n.x||1!==n.y?(new s.Matrix4).set(r.x,n.x,0,t.x,r.y,n.y,0,t.y,0,0,1,0,0,0,0,1):void 0}(e));return n.name=t,n.matrix=function(e){var t=e.getElementsByTagName("ConvOri")[0];e=e.getElementsByTagName("Externe")[0],t=O(e)||O(t);var r=e.getElementsByTagName("ParamRotation")[0],n=r&&r.children[0]?r.children[0].tagName:"No or empty ParamRotation tag",i=new s.Matrix4;switch(n){case"CodageMatr":var o=_(r,"L1"),a=_(r,"L2"),c=_(r,"L3");i.set(o[0],o[1],o[2],0,a[0],a[1],a[2],0,c[0],c[1],c[2],0,0,0,0,1);break;case"CodageAngulaire":console.warn("CodageAngulaire has never been tested");var l=_(r,"CodageAngulaire").map(e=>e*t.scale),u=new s.Euler(l[0],l[1],l[2],t.order);i.makeRotationFromEuler(u);break;default:throw new Error("Error parsing micmac orientation, rotation encoding : "+n)}t.MatrC2M||i.transpose();for(var h=0;h<3;++h)for(var d=0;d<3;++d)i.elements[4*d+h]*=t.col[d]*t.lin[h];return i.setPosition(D(e,"Centre")),i.scale(new s.Vector3(1,-1,-1)),i}(e),n.matrix.decompose(n.position,n.quaternion,n.scale),n.updateMatrixWorld(!0),n.check=function(e){if(e=e.getElementsByTagName("Verif")[0])return t.epsilon=_(e,"Tol")[0],t.points=Array.from(e.getElementsByTagName("Appuis")).map(e=>({id:_(e,"Num")[0],p2:S(e,"Im"),p3:D(e,"Ter")})),t;function t(e,t){return e=e||this.check.epsilon,(t?this.check.points.slice(0,t):this.check.points).reduce((t,r)=>{var n=this.distort(r.p3.clone()),i=r.p2.distanceTo(n);return i>e&&(t=!1,console.warn(r.id,i,n,r.p2,r.p3)),t},!0)}}(e),n}var L={parse:function(e,t,r){e instanceof Node||(e=(new window.DOMParser).parseFromString(e,"text/xml"));const n=r.match(/Orientation-(.*)\.[\w\d]*\.xml/i);if(n&&(r=n[1]),e=e.getElementsByTagName("OrientationConique")[0]){var i=T(e,"FileInterne"),o=T(e,"TypeProj");if("eProjStenope"!==o){var s=new Error("Error parsing micmac orientation : unknown projection type "+o);return Promise.reject(s)}if(i)return t.open(i,"text").then(t=>N(e,r,t));var a=e.getElementsByTagName("Interne")[0];return Promise.resolve(N(e,r,a))}},format:"micmac/orientation",extensions:["xml"],mimetypes:["application/xml"],fetchtype:"xml"},z={parse:function(e,t,r){const n=e.split(/\n/),i=["CHANTIER : ","PROJECTION : ","REFERENTIEL ALTIMETRIQUE : ","UNITE ANGLE  : ","NOM\tX\tY\tZ\tO\tP\tK\tCAMERA"];for(var o=0;o<i.length;++o)if(!n[o].startsWith(i[o]))return null;n[0].substr(i[0].length);const a=n[1].substr(i[1].length);console.warn("projection not used ",a);const c=n[2].substr(i[2].length);console.warn("alti not used ",c);const l="degre"==n[3].substr(i[3].length).trim(),u=[],h=new s.Euler(0,0,0,"XYZ");for(o=5;o<n.length&&""!=n[o].trim();++o){const e=n[o].split(/\s+/),r=e[0],i=Number(e[1]),a=Number(e[2]),c=Number(e[3]);var d=Number(e[4]),m=Number(e[5]),f=Number(e[6]);const p=t.cameras[e[7]].clone();l&&(d=s.Math.degToRad(d),m=s.Math.degToRad(m),f=s.Math.degToRad(f)),h.set(d,m,f),p.position.set(i,a,c),p.quaternion.setFromEuler(h),p.name=r,p.near=100,p.far=1e4,u.push(p)}return u},parseXYZ(e,t){const r=e.split(/\n/);if(!r[0].startsWith("ID\tX\tY\tZ\tMult\tStrip"))return console.error("Error parsing XYZ file line 0",r[0],t),null;""==r[r.length-1].trim()&&(r.length=r.length-1);const n=r.length-1,i=new Float32Array(3*n),o=new Uint16Array(n),s=new Uint16Array(n),a=[];for(var c=0;c<n;++c){const e=r[1+c].split(/\s+/);a[c]=e[0],i[3*c+0]=Number(e[1]),i[3*c+1]=Number(e[2]),i[3*c+2]=Number(e[3]),o[c]=Number(e[4]),s[c]=Number(e[5])}return{size:n,position:i,multi:o,strip:s,name:a}},parseMES(e,t){const r=e.split(/\n/);if(""!==r[0].trim())return console.error("Error parsing MES file line 0",t),null;""==r[r.length-1].trim()&&(r.length=r.length-1);const n=r.length-1,i=new Float32Array(2*n),o=[],s=[];for(var a=0;a<n;++a){const e=r[1+a].split(/\s+/);o[a]=e[0],s[a]=e[1],i[2*a+0]=Number(e[2]),i[2*a+1]=Number(e[3])}return{size:n,position:i,name:o,image:s}},format:"OPK/orientation",extensions:["opk"],mimetypes:["application/text"],fetchtype:"text"},k={serializeFeature:function(e,t){const r=e.distos?e.distos[0]:{},n=e.imageMatrix.elements;return{type:"Feature",geometry:{type:"Point",coordinates:[e.position.x,e.position.y,e.position.z]},properties:{name:e.name,epsgquaternion:"4978",source:"0",fx:e.focal.x,fy:e.focal.y,sx:e.view.fullWidth,sy:e.view.fullHeight,px:e.point.x,py:e.point.y,cx:r.C.x,cy:r.C.y,c3:r.R.x,c5:r.R.y,c7:r.R.z,cm:r.R.w,m00:n[0],m01:n[1],m10:n[4],m11:n[5],m20:n[12],m21:n[13],qx:e.quaternion.x,qy:e.quaternion.y,qz:e.quaternion.z,qw:e.quaternion.w}}},serialize(e,t){e.children&&(e=e.children);const r={type:"FeatureCollection",features:e.map(e=>this.serializeFeature(e,t)),crs:{type:"name",properties:{name:t}}};return JSON.stringify(r)}},j={serialize:function(e,t){const r=e.distos?e.distos[0]:{},n=e.imageMatrix.elements,i=e.position,o=e.focal,s=e.view,a=e.point,c=e.quaternion;return`<point>\n  <gml:Point srsName="http://www.opengis.net/gml/srs/epsg.xml#4978">\n    <gml:coordinates xmlns:gml="http://www.opengis.net/gml" decimal="." cs="," ts=" ">${i.x},${i.y},${i.z}</gml:coordinates>\n  </gml:Point>\n</point>\n<name>${e.name}</name>\n<source>0</source>\n<epsgquaternion>4978</epsgquaternion>\n<qx>${c.x}</qx>\n<qy>${c.y}</qy>\n<qz>${c.z}</qz>\n<qw>${c.w}</qw>\n<fx>${o.x}</fx>\n<fy>${o.y}</fy>\n<px>${a.x}</px>\n<py>${a.y}</py>\n<sk>0.0</sk>\n<sx>${s.fullWidth}</sx>\n<sy>${s.fullHeight}</sy>\n<c3>${r.R.x}</c3>\n<c5>${r.R.y}</c5>\n<c7>${r.R.z}</c7>\n<cm>${r.R.w}</cm>\n<cx>${r.C.x}</cx>\n<cy>${r.C.y}</cy>\n<m00>${n[0]}</m00>\n<m01>${n[1]}</m01>\n<m10>${n[4]}</m10>\n<m11>${n[5]}</m11>\n<m20>${n[12]}</m20>\n<m21>${n[13]}</m21>`}};const U={type:"change"},V={type:"start"},F={type:"end"};class I extends s.EventDispatcher{constructor(e,t){super(),void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new s.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:s.MOUSE.ROTATE,MIDDLE:s.MOUSE.DOLLY,RIGHT:s.MOUSE.PAN},this.touches={ONE:s.TOUCH.ROTATE,TWO:s.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.listenToKeyEvents=function(e){e.addEventListener("keydown",Y),this._domElementKeyEvents=e},this.saveState=function(){r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=function(){r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(U),r.update(),i=n.NONE},this.update=function(){const t=new s.Vector3,d=(new s.Quaternion).setFromUnitVectors(e.up,new s.Vector3(0,1,0)),m=d.clone().invert(),f=new s.Vector3,p=new s.Quaternion,v=2*Math.PI;return function(){const e=r.object.position;t.copy(e).sub(r.target),t.applyQuaternion(d),a.setFromVector3(t),r.autoRotate&&i===n.NONE&&M(2*Math.PI/60/60*r.autoRotateSpeed),r.enableDamping?(a.theta+=c.theta*r.dampingFactor,a.phi+=c.phi*r.dampingFactor):(a.theta+=c.theta,a.phi+=c.phi);let s=r.minAzimuthAngle,g=r.maxAzimuthAngle;return isFinite(s)&&isFinite(g)&&(s<-Math.PI?s+=v:s>Math.PI&&(s-=v),g<-Math.PI?g+=v:g>Math.PI&&(g-=v),a.theta=s<=g?Math.max(s,Math.min(g,a.theta)):a.theta>(s+g)/2?Math.max(s,a.theta):Math.min(g,a.theta)),a.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,a.phi)),a.makeSafe(),a.radius*=l,a.radius=Math.max(r.minDistance,Math.min(r.maxDistance,a.radius)),!0===r.enableDamping?r.target.addScaledVector(u,r.dampingFactor):r.target.add(u),t.setFromSpherical(a),t.applyQuaternion(m),e.copy(r.target).add(t),r.object.lookAt(r.target),!0===r.enableDamping?(c.theta*=1-r.dampingFactor,c.phi*=1-r.dampingFactor,u.multiplyScalar(1-r.dampingFactor)):(c.set(0,0,0),u.set(0,0,0)),l=1,!!(h||f.distanceToSquared(r.object.position)>o||8*(1-p.dot(r.object.quaternion))>o)&&(r.dispatchEvent(U),f.copy(r.object.position),p.copy(r.object.quaternion),h=!1,!0)}}(),this.dispose=function(){r.domElement.removeEventListener("contextmenu",G),r.domElement.removeEventListener("pointerdown",j),r.domElement.removeEventListener("wheel",B),r.domElement.removeEventListener("touchstart",X),r.domElement.removeEventListener("touchend",W),r.domElement.removeEventListener("touchmove",q),r.domElement.ownerDocument.removeEventListener("pointermove",I),r.domElement.ownerDocument.removeEventListener("pointerup",H),null!==r._domElementKeyEvents&&r._domElementKeyEvents.removeEventListener("keydown",Y)};const r=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=n.NONE;const o=1e-6,a=new s.Spherical,c=new s.Spherical;let l=1;const u=new s.Vector3;let h=!1;const d=new s.Vector2,m=new s.Vector2,f=new s.Vector2,p=new s.Vector2,v=new s.Vector2,g=new s.Vector2,w=new s.Vector2,x=new s.Vector2,y=new s.Vector2;function b(){return Math.pow(.95,r.zoomSpeed)}function M(e){c.theta-=e}function C(e){c.phi-=e}const P=function(){const e=new s.Vector3;return function(t,r){e.setFromMatrixColumn(r,0),e.multiplyScalar(-t),u.add(e)}}(),E=function(){const e=new s.Vector3;return function(t,n){!0===r.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(r.object.up,e)),e.multiplyScalar(t),u.add(e)}}(),T=function(){const e=new s.Vector3;return function(t,n){const i=r.domElement;if(r.object.isPerspectiveCamera){const o=r.object.position;e.copy(o).sub(r.target);let s=e.length();s*=Math.tan(r.object.fov/2*Math.PI/180),P(2*t*s/i.clientHeight,r.object.matrix),E(2*n*s/i.clientHeight,r.object.matrix)}else r.object.isOrthographicCamera?(P(t*(r.object.right-r.object.left)/r.object.zoom/i.clientWidth,r.object.matrix),E(n*(r.object.top-r.object.bottom)/r.object.zoom/i.clientHeight,r.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),r.enablePan=!1)}}();function _(e){r.object.isPerspectiveCamera?l/=e:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom*e)),r.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function S(e){r.object.isPerspectiveCamera?l*=e:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/e)),r.object.updateProjectionMatrix(),h=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function D(e){d.set(e.clientX,e.clientY)}function R(e){p.set(e.clientX,e.clientY)}function A(e){if(1==e.touches.length)d.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);d.set(t,r)}}function O(e){if(1==e.touches.length)p.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);p.set(t,r)}}function N(e){const t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,n=Math.sqrt(t*t+r*r);w.set(0,n)}function L(e){if(1==e.touches.length)m.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);m.set(t,r)}f.subVectors(m,d).multiplyScalar(r.rotateSpeed);const t=r.domElement;M(2*Math.PI*f.x/t.clientHeight),C(2*Math.PI*f.y/t.clientHeight),d.copy(m)}function z(e){if(1==e.touches.length)v.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);v.set(t,r)}g.subVectors(v,p).multiplyScalar(r.panSpeed),T(g.x,g.y),p.copy(v)}function k(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);x.set(0,i),y.set(0,Math.pow(x.y/w.y,r.zoomSpeed)),_(y.y),w.copy(x)}function j(e){if(!1!==r.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){let t;switch(e.preventDefault(),r.domElement.focus?r.domElement.focus():window.focus(),e.button){case 0:t=r.mouseButtons.LEFT;break;case 1:t=r.mouseButtons.MIDDLE;break;case 2:t=r.mouseButtons.RIGHT;break;default:t=-1}switch(t){case s.MOUSE.DOLLY:if(!1===r.enableZoom)return;!function(e){w.set(e.clientX,e.clientY)}(e),i=n.DOLLY;break;case s.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===r.enablePan)return;R(e),i=n.PAN}else{if(!1===r.enableRotate)return;D(e),i=n.ROTATE}break;case s.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===r.enableRotate)return;D(e),i=n.ROTATE}else{if(!1===r.enablePan)return;R(e),i=n.PAN}break;default:i=n.NONE}i!==n.NONE&&(r.domElement.ownerDocument.addEventListener("pointermove",I),r.domElement.ownerDocument.addEventListener("pointerup",H),r.dispatchEvent(V))}(e)}}function I(e){if(!1!==r.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===r.enabled)return;switch(e.preventDefault(),i){case n.ROTATE:if(!1===r.enableRotate)return;!function(e){m.set(e.clientX,e.clientY),f.subVectors(m,d).multiplyScalar(r.rotateSpeed);const t=r.domElement;M(2*Math.PI*f.x/t.clientHeight),C(2*Math.PI*f.y/t.clientHeight),d.copy(m),r.update()}(e);break;case n.DOLLY:if(!1===r.enableZoom)return;!function(e){x.set(e.clientX,e.clientY),y.subVectors(x,w),y.y>0?_(b()):y.y<0&&S(b()),w.copy(x),r.update()}(e);break;case n.PAN:if(!1===r.enablePan)return;!function(e){v.set(e.clientX,e.clientY),g.subVectors(v,p).multiplyScalar(r.panSpeed),T(g.x,g.y),p.copy(v),r.update()}(e)}}(e)}}function H(e){switch(e.pointerType){case"mouse":case"pen":!function(e){if(r.domElement.ownerDocument.removeEventListener("pointermove",I),r.domElement.ownerDocument.removeEventListener("pointerup",H),!1===r.enabled)return;r.dispatchEvent(F),i=n.NONE}()}}function B(e){!1===r.enabled||!1===r.enableZoom||i!==n.NONE&&i!==n.ROTATE||(e.preventDefault(),r.dispatchEvent(V),function(e){e.deltaY<0?S(b()):e.deltaY>0&&_(b()),r.update()}(e),r.dispatchEvent(F))}function Y(e){!1!==r.enabled&&!1!==r.enablePan&&function(e){let t=!1;switch(e.code){case r.keys.UP:T(0,r.keyPanSpeed),t=!0;break;case r.keys.BOTTOM:T(0,-r.keyPanSpeed),t=!0;break;case r.keys.LEFT:T(r.keyPanSpeed,0),t=!0;break;case r.keys.RIGHT:T(-r.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),r.update())}(e)}function X(e){if(!1!==r.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(r.touches.ONE){case s.TOUCH.ROTATE:if(!1===r.enableRotate)return;A(e),i=n.TOUCH_ROTATE;break;case s.TOUCH.PAN:if(!1===r.enablePan)return;O(e),i=n.TOUCH_PAN;break;default:i=n.NONE}break;case 2:switch(r.touches.TWO){case s.TOUCH.DOLLY_PAN:if(!1===r.enableZoom&&!1===r.enablePan)return;!function(e){r.enableZoom&&N(e),r.enablePan&&O(e)}(e),i=n.TOUCH_DOLLY_PAN;break;case s.TOUCH.DOLLY_ROTATE:if(!1===r.enableZoom&&!1===r.enableRotate)return;!function(e){r.enableZoom&&N(e),r.enableRotate&&A(e)}(e),i=n.TOUCH_DOLLY_ROTATE;break;default:i=n.NONE}break;default:i=n.NONE}i!==n.NONE&&r.dispatchEvent(V)}}function q(e){if(!1!==r.enabled)switch(e.preventDefault(),i){case n.TOUCH_ROTATE:if(!1===r.enableRotate)return;L(e),r.update();break;case n.TOUCH_PAN:if(!1===r.enablePan)return;z(e),r.update();break;case n.TOUCH_DOLLY_PAN:if(!1===r.enableZoom&&!1===r.enablePan)return;!function(e){r.enableZoom&&k(e),r.enablePan&&z(e)}(e),r.update();break;case n.TOUCH_DOLLY_ROTATE:if(!1===r.enableZoom&&!1===r.enableRotate)return;!function(e){r.enableZoom&&k(e),r.enableRotate&&L(e)}(e),r.update();break;default:i=n.NONE}}function W(e){!1!==r.enabled&&(r.dispatchEvent(F),i=n.NONE)}function G(e){!1!==r.enabled&&e.preventDefault()}r.domElement.addEventListener("contextmenu",G),r.domElement.addEventListener("pointerdown",j),r.domElement.addEventListener("wheel",B,{passive:!1}),r.domElement.addEventListener("touchstart",X,{passive:!1}),r.domElement.addEventListener("touchend",W),r.domElement.addEventListener("touchmove",q,{passive:!1}),this.update()}}class H extends I{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=s.MOUSE.PAN,this.mouseButtons.RIGHT=s.MOUSE.ROTATE,this.touches.ONE=s.TOUCH.PAN,this.touches.TWO=s.TOUCH.DOLLY_ROTATE}}const B=new s.Vector3,Y=new s.Spherical,X=new s.Vector3;class q{constructor(e,t){void 0===t&&(console.warn('THREE.FirstPersonControls: The second parameter "domElement" is now mandatory.'),t=document),this.object=e,this.domElement=t,this.enabled=!0,this.movementSpeed=1,this.lookSpeed=.005,this.lookVertical=!0,this.autoForward=!1,this.activeLook=!0,this.heightSpeed=!1,this.heightCoef=1,this.heightMin=0,this.heightMax=1,this.constrainVertical=!1,this.verticalMin=0,this.verticalMax=Math.PI,this.mouseDragOn=!1,this.autoSpeedFactor=0,this.mouseX=0,this.mouseY=0,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.viewHalfX=0,this.viewHalfY=0;let r=0,n=0;this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)},this.onMouseDown=function(e){if(this.domElement!==document&&this.domElement.focus(),e.preventDefault(),this.activeLook)switch(e.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0},this.onMouseUp=function(e){if(e.preventDefault(),this.activeLook)switch(e.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1},this.onMouseMove=function(e){this.domElement===document?(this.mouseX=e.pageX-this.viewHalfX,this.mouseY=e.pageY-this.viewHalfY):(this.mouseX=e.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=e.pageY-this.domElement.offsetTop-this.viewHalfY)},this.onKeyDown=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!0;break;case"ArrowLeft":case"KeyA":this.moveLeft=!0;break;case"ArrowDown":case"KeyS":this.moveBackward=!0;break;case"ArrowRight":case"KeyD":this.moveRight=!0;break;case"KeyR":this.moveUp=!0;break;case"KeyF":this.moveDown=!0}},this.onKeyUp=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!1;break;case"ArrowLeft":case"KeyA":this.moveLeft=!1;break;case"ArrowDown":case"KeyS":this.moveBackward=!1;break;case"ArrowRight":case"KeyD":this.moveRight=!1;break;case"KeyR":this.moveUp=!1;break;case"KeyF":this.moveDown=!1}},this.lookAt=function(e,t,r){return e.isVector3?X.copy(e):X.set(e,t,r),this.object.lookAt(X),u(this),this},this.update=function(){const e=new s.Vector3;return function(t){if(!1===this.enabled)return;if(this.heightSpeed){const e=s.MathUtils.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=t*(e*this.heightCoef)}else this.autoSpeedFactor=0;const i=t*this.movementSpeed;(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(i+this.autoSpeedFactor)),this.moveBackward&&this.object.translateZ(i),this.moveLeft&&this.object.translateX(-i),this.moveRight&&this.object.translateX(i),this.moveUp&&this.object.translateY(i),this.moveDown&&this.object.translateY(-i);let o=t*this.lookSpeed;this.activeLook||(o=0);let a=1;this.constrainVertical&&(a=Math.PI/(this.verticalMax-this.verticalMin)),n-=this.mouseX*o,this.lookVertical&&(r-=this.mouseY*o*a),r=Math.max(-85,Math.min(85,r));let c=s.MathUtils.degToRad(90-r);const l=s.MathUtils.degToRad(n);this.constrainVertical&&(c=s.MathUtils.mapLinear(c,0,Math.PI,this.verticalMin,this.verticalMax));const u=this.object.position;e.setFromSphericalCoords(1,c,l).add(u),this.object.lookAt(e)}}(),this.dispose=function(){this.domElement.removeEventListener("contextmenu",W),this.domElement.removeEventListener("mousedown",o),this.domElement.removeEventListener("mousemove",i),this.domElement.removeEventListener("mouseup",a),window.removeEventListener("keydown",c),window.removeEventListener("keyup",l)};const i=this.onMouseMove.bind(this),o=this.onMouseDown.bind(this),a=this.onMouseUp.bind(this),c=this.onKeyDown.bind(this),l=this.onKeyUp.bind(this);function u(e){const t=e.object.quaternion;B.set(0,0,-1).applyQuaternion(t),Y.setFromVector3(B),r=90-s.MathUtils.radToDeg(Y.phi),n=s.MathUtils.radToDeg(Y.theta)}this.domElement.addEventListener("contextmenu",W),this.domElement.addEventListener("mousemove",i),this.domElement.addEventListener("mousedown",o),this.domElement.addEventListener("mouseup",a),window.addEventListener("keydown",c),window.addEventListener("keyup",l),this.handleResize(),u(this)}}function W(e){e.preventDefault()}class G extends s.Loader{constructor(e){super(e),this.propertyNameMapping={}}load(e,t,r,n){const i=this,o=new s.FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,(function(r){try{t(i.parse(r))}catch(t){n?n(t):console.error(t),i.manager.itemError(e)}}),r,n)}setPropertyNameMapping(e){this.propertyNameMapping=e}parse(e){function t(e){let t="",r=0;const n=/ply([\s\S]*)end_header\r?\n/.exec(e);null!==n&&(t=n[1],r=new Blob([n[0]]).size);const i={comments:[],elements:[],headerLength:r,objInfo:""},o=t.split("\n");let s;function a(e,t){const r={type:e[0]};return"list"===r.type?(r.name=e[3],r.countType=e[1],r.itemType=e[2]):r.name=e[1],r.name in t&&(r.name=t[r.name]),r}for(let e=0;e<o.length;e++){let t=o[e];if(t=t.trim(),""===t)continue;const r=t.split(/\s+/),n=r.shift();switch(t=r.join(" "),n){case"format":i.format=r[0],i.version=r[1];break;case"comment":i.comments.push(t);break;case"element":void 0!==s&&i.elements.push(s),s={},s.name=r[0],s.count=parseInt(r[1]),s.properties=[];break;case"property":s.properties.push(a(r,h.propertyNameMapping));break;case"obj_info":i.objInfo=t;break;default:console.log("unhandled",n,r)}}return void 0!==s&&i.elements.push(s),i}function r(e,t){switch(t){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(e);case"float":case"double":case"float32":case"float64":return parseFloat(e)}}function n(e,t){const n=t.split(/\s+/),i={};for(let t=0;t<e.length;t++)if("list"===e[t].type){const o=[],s=r(n.shift(),e[t].countType);for(let i=0;i<s;i++)o.push(r(n.shift(),e[t].itemType));i[e[t].name]=o}else i[e[t].name]=r(n.shift(),e[t].type);return i}function i(e,t){const r={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]};let i;let s="";null!==(i=/end_header\s([\s\S]*)$/.exec(e))&&(s=i[1]);const c=s.split("\n");let l=0,u=0;for(let e=0;e<c.length;e++){let i=c[e];if(i=i.trim(),""===i)continue;u>=t.elements[l].count&&(l++,u=0);const o=n(t.elements[l].properties,i);a(r,t.elements[l].name,o),u++}return o(r)}function o(e){let t=new s.BufferGeometry;return e.indices.length>0&&t.setIndex(e.indices),t.setAttribute("position",new s.Float32BufferAttribute(e.vertices,3)),e.normals.length>0&&t.setAttribute("normal",new s.Float32BufferAttribute(e.normals,3)),e.uvs.length>0&&t.setAttribute("uv",new s.Float32BufferAttribute(e.uvs,2)),e.colors.length>0&&t.setAttribute("color",new s.Float32BufferAttribute(e.colors,3)),e.faceVertexUvs.length>0&&(t=t.toNonIndexed(),t.setAttribute("uv",new s.Float32BufferAttribute(e.faceVertexUvs,2))),t.computeBoundingSphere(),t}function a(e,t,r){if("vertex"===t)e.vertices.push(r.x,r.y,r.z),"nx"in r&&"ny"in r&&"nz"in r&&e.normals.push(r.nx,r.ny,r.nz),"s"in r&&"t"in r&&e.uvs.push(r.s,r.t),"red"in r&&"green"in r&&"blue"in r&&e.colors.push(r.red/255,r.green/255,r.blue/255);else if("face"===t){const t=r.vertex_indices||r.vertex_index,n=r.texcoord;3===t.length?(e.indices.push(t[0],t[1],t[2]),n&&6===n.length&&(e.faceVertexUvs.push(n[0],n[1]),e.faceVertexUvs.push(n[2],n[3]),e.faceVertexUvs.push(n[4],n[5]))):4===t.length&&(e.indices.push(t[0],t[1],t[3]),e.indices.push(t[1],t[2],t[3]))}}function c(e,t,r,n){switch(r){case"int8":case"char":return[e.getInt8(t),1];case"uint8":case"uchar":return[e.getUint8(t),1];case"int16":case"short":return[e.getInt16(t,n),2];case"uint16":case"ushort":return[e.getUint16(t,n),2];case"int32":case"int":return[e.getInt32(t,n),4];case"uint32":case"uint":return[e.getUint32(t,n),4];case"float32":case"float":return[e.getFloat32(t,n),4];case"float64":case"double":return[e.getFloat64(t,n),8]}}function l(e,t,r,n){const i={};let o,s=0;for(let a=0;a<r.length;a++)if("list"===r[a].type){const l=[];o=c(e,t+s,r[a].countType,n);const u=o[0];s+=o[1];for(let i=0;i<u;i++)o=c(e,t+s,r[a].itemType,n),l.push(o[0]),s+=o[1];i[r[a].name]=l}else o=c(e,t+s,r[a].type,n),i[r[a].name]=o[0],s+=o[1];return[i,s]}let u;const h=this;if(e instanceof ArrayBuffer){const r=s.LoaderUtils.decodeText(new Uint8Array(e)),n=t(r);u="ascii"===n.format?i(r,n):function(e,t){const r={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]},n="binary_little_endian"===t.format,i=new DataView(e,t.headerLength);let s,c=0;for(let e=0;e<t.elements.length;e++)for(let o=0;o<t.elements[e].count;o++){s=l(i,c,t.elements[e].properties,n),c+=s[1];const o=s[0];a(r,t.elements[e].name,o)}return o(r)}(e,n)}else u=i(e,t(e));return u}}var Z={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"};class K{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const $=new s.OrthographicCamera(-1,1,1,-1,0,1),Q=new s.BufferGeometry;Q.setAttribute("position",new s.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),Q.setAttribute("uv",new s.Float32BufferAttribute([0,2,0,0,2,0],2));class J{constructor(e){this._mesh=new s.Mesh(Q,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,$)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class ee extends K{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof s.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=s.UniformsUtils.clone(e.uniforms),this.material=new s.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new J(this.material)}render(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}class te extends K{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,r){const n=e.getContext(),i=e.state;let o,s;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(o=0,s=1):(o=1,s=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),i.buffers.stencil.setFunc(n.ALWAYS,o,4294967295),i.buffers.stencil.setClear(s),i.buffers.stencil.setLocked(!0),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(n.EQUAL,1,4294967295),i.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),i.buffers.stencil.setLocked(!0)}}class re extends K{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class ne{constructor(e,t){if(this.renderer=e,void 0===t){const r={minFilter:s.LinearFilter,magFilter:s.LinearFilter,format:s.RGBAFormat},n=e.getSize(new s.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=n.width,this._height=n.height,(t=new s.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,r)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===Z&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===ee&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new ee(Z),this.clock=new s.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let r=!1;for(let t=0,n=this.passes.length;t<n;t++){const n=this.passes[t];if(!1!==n.enabled){if(n.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),n.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),n.needsSwap){if(r){const t=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),r.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==te&&(n instanceof te?r=!0:n instanceof re&&(r=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new s.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(r,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new s.OrthographicCamera(-1,1,1,-1,0,1);const ie=new s.BufferGeometry;ie.setAttribute("position",new s.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),ie.setAttribute("uv",new s.Float32BufferAttribute([0,2,0,0,2,0],2));class oe extends K{constructor(e,t,r,n,i){super(),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=n,this.clearAlpha=void 0!==i?i:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new s.Color}render(e,t,r){const n=e.autoClear;let i,o;e.autoClear=!1,void 0!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),i=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,i),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=n}}class se{static isWebGLAvailable(){try{const e=document.createElement("canvas");return!(!window.WebGLRenderingContext||!e.getContext("webgl")&&!e.getContext("experimental-webgl"))}catch(e){return!1}}static isWebGL2Available(){try{const e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))}catch(e){return!1}}static getWebGLErrorMessage(){return this.getErrorMessage(1)}static getWebGL2ErrorMessage(){return this.getErrorMessage(2)}static getErrorMessage(e){const t={1:window.WebGLRenderingContext,2:window.WebGL2RenderingContext};let r='Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';const n=document.createElement("div");return n.id="webglmessage",n.style.fontFamily="monospace",n.style.fontSize="13px",n.style.fontWeight="normal",n.style.textAlign="center",n.style.background="#fff",n.style.color="#000",n.style.padding="1.5em",n.style.width="400px",n.style.margin="5em auto 0",r=t[e]?r.replace("$0","graphics card"):r.replace("$0","browser"),r=r.replace("$1",{1:"WebGL",2:"WebGL 2"}[e]),n.innerHTML=r,n}}function ae(e,t){return new Promise((r,n)=>{var i=new FileReader;switch(i.onload=()=>{r(i.result)},i.onerror=()=>{i.abort(),n(new DOMException("FileReader error."))},t){case"text":i.readAsText(e);break;case"arrayBuffer":i.readAsArrayBuffer(e);break;case"dataURL":i.readAsDataURL(e);break;default:console.error("unknown decode type",t)}})}var ce=class{constructor(e,t={}){this.path=t.path||(e=>e.substr(e.lastIndexOf("/")+1)),this.files={};for(let t=0;t<e.length;++t)this.files[e[t].name]=e[t];this.decode=t.decode||ae}open(e,t){e=this.path(e);const r=this.files[e];return r?this.decode(r,t):Promise.reject(new Error("file not found: "+e))}close(e,t){}};const le=window.fetch.bind(window),ue=window.URL||window.webkitURL;function he(e,t){if(!e.ok){const t=new Error(`Error loading ${e.url}: status ${e.status}`);throw t.response=e,t}switch(t){case"text":return e.text();case"arrayBuffer":return e.arrayBuffer();case"dataURL":return e.blob().then(ue.createObjectURL);default:console.error("unknown decode type",t)}}var de=class{constructor(e,t={}){this.path=e||"",this.fetchOptions=t.fetchOptions||{crossOrigin:"anonymous"},this.fetch=t.fetch||le,this.decode=t.decode||he}open(e,t){return e.startsWith("http")||(e=this.path+e),this.fetch(e,this.fetchOptions).then(e=>this.decode(e,t))}close(e,t){"dataURL"===t&&ue.revokeObjectURL(e)}};function me(e,t,r){if(void 0===e[t])return r;const n=e[t];return delete e[t],n}function fe(e,t,r){e.uniforms[t]=new s.Uniform(e[t]||r),Object.defineProperty(e,t,{get:()=>e.uniforms[t].value,set:r=>{e.uniforms[t].value!=r&&(e.uniformsNeedUpdate=!0,e.uniforms[t].value=r)}})}const pe=(new s.Matrix4).set(1,0,0,1,0,1,0,1,0,0,1,1,0,0,0,2);var ve=r(1),ge=r.n(ve),we=r(2),xe=r.n(we);class ye extends s.ShaderMaterial{constructor(e={}){const t=me(e,"size",1),r=me(e,"diffuse",new s.Color(15658734)),n=me(e,"uvwPosition",new s.Vector3),i=me(e,"uvwPreTransform",new s.Matrix4),o=me(e,"uvwPostTransform",new s.Matrix4),a=me(e,"uvDistortion",{R:new s.Vector4,C:new s.Vector2}),c=me(e,"map",null),l=me(e,"alphaMap",null),u=me(e,"scale",1),h=me(e,"borderSharpness",1e4),d=me(e,"diffuseColorGrey",!0),m=me(e,"debugOpacity",0);e.vertexShader=e.vertexShader||ge.a,e.fragmentShader=e.fragmentShader||xe.a,e.defines=e.defines||{},c&&(e.defines.USE_MAP4=""),l&&(e.defines.USE_ALPHAMAP=""),e.vertexColors&&(e.defines.USE_COLOR=""),e.logarithmicDepthBuffer&&(e.defines.USE_LOGDEPTHBUF=""),me(e,"sizeAttenuation")&&(e.defines.USE_SIZEATTENUATION=""),super(e),fe(this,"size",t),fe(this,"diffuse",r),fe(this,"uvwPosition",n),fe(this,"uvwPreTransform",i),fe(this,"uvwPostTransform",o),fe(this,"uvDistortion",a),fe(this,"opacity",this.opacity),fe(this,"map",c),fe(this,"alphaMap",l),fe(this,"scale",u),fe(this,"borderSharpness",h),fe(this,"diffuseColorGrey",d),fe(this,"debugOpacity",m)}setCamera(e){e.getWorldPosition(this.uvwPosition),this.uvwPreTransform.copy(e.matrixWorldInverse),this.uvwPreTransform.setPosition(0,0,0),this.uvwPreTransform.premultiply(e.preProjectionMatrix),this.uvwPostTransform.copy(e.postProjectionMatrix),this.uvwPostTransform.premultiply(pe),e.distos&&1==e.distos.length&&e.distos[0].isRadialDistortion?this.uvDistortion=e.distos[0]:(this.uvDistortion={C:new THREE.Vector2,R:new THREE.Vector4},this.uvDistortion.R.w=1/0)}}var be=ye,Me=r(3),Ce=r.n(Me),Pe=r(4),Ee=r.n(Pe);class Te extends s.ShaderMaterial{constructor(e={}){const t=me(e,"size",1),r=me(e,"textureCameraPosition",new s.Vector3),n=me(e,"textureCameraPreTransform",new s.Matrix4),i=me(e,"uvwPostTransform",new s.Matrix4),o=me(e,"uvDistortion",{R:new s.Vector4,C:new s.Vector3}),a=me(e,"map",null),c=me(e,"depthMap",null),l=me(e,"diffuseColorGrey",!0);e.defines=e.defines||{},e.defines.USE_COLOR="",a&&(e.defines.USE_PROJECTIVE_TEXTURING="",e.defines.EPSILON=.001),super(e),fe(this,"size",t),fe(this,"textureCameraPosition",r),fe(this,"textureCameraPreTransform",n),fe(this,"textureCameraPostTransform",i),fe(this,"uvDistortion",o),fe(this,"map",a),fe(this,"depthMap",c),fe(this,"diffuseColorGrey",l),this.vertexShader=Ce.a,this.fragmentShader=Ee.a}setCamera(e){e.getWorldPosition(this.textureCameraPosition),this.textureCameraPreTransform.copy(e.matrixWorldInverse),this.textureCameraPreTransform.setPosition(0,0,0),this.textureCameraPreTransform.premultiply(e.preProjectionMatrix),this.textureCameraPostTransform.copy(e.postProjectionMatrix),this.textureCameraPostTransform.premultiply(pe),e.distos&&1==e.distos.length&&e.distos[0].isRadialDistortion?this.uvDistortion=e.distos[0]:(this.uvDistortion={C:new THREE.Vector2,R:new THREE.Vector4},this.uvDistortion.R.w=1/0)}}var _e=Te,Se=r(5),De=r.n(Se),Re=r(6),Ae=r.n(Re);class Oe extends s.ShaderMaterial{constructor(){super(),this.vertexShader=De.a,this.fragmentShader=Ae.a,this.uniforms.size=new s.Uniform(3)}}var Ne=Oe,Le=r(7),ze=r.n(Le),ke=r(8),je=r.n(ke);class Ue extends s.ShaderMaterial{constructor(){super(),this.uniforms.screenSize=new s.Uniform(new s.Vector2),fe(this,"size",3),fe(this,"textureCameraPosition",new s.Vector3),fe(this,"textureCameraPreTransform",new s.Matrix4),fe(this,"textureCameraPostTransform",new s.Matrix4),fe(this,"viewProjectionScreenInverse",new s.Matrix3),fe(this,"M_prime_Pre",new s.Matrix3),fe(this,"M_prime_Post",new s.Matrix3),fe(this,"E_prime",new s.Vector3),fe(this,"uvDistortion",{R:new s.Vector4,C:new s.Vector3}),fe(this,"map",null),fe(this,"depthMap",null),fe(this,"screenSize",new s.Vector2),fe(this,"diffuseColorGrey",!0),this.defines.USE_COLOR="",this.defines.EPSILON=.001,this.vertexShader=ze.a,this.fragmentShader=je.a}setCamera(e){e.getWorldPosition(this.textureCameraPosition),this.textureCameraPreTransform.copy(e.matrixWorldInverse),this.textureCameraPreTransform.setPosition(0,0,0),this.textureCameraPreTransform.premultiply(e.preProjectionMatrix),this.textureCameraPostTransform.copy(e.postProjectionMatrix),this.textureCameraPostTransform.premultiply(pe);var t=this.textureCameraPreTransform.elements;this.M_prime_Pre.set(t[0],t[4],t[8],t[1],t[5],t[9],t[3],t[7],t[11]);var r=this.textureCameraPostTransform.elements;this.M_prime_Post.set(r[0],r[4],r[12],r[1],r[5],r[13],r[3],r[7],r[15]),e.distos&&1==e.distos.length&&e.distos[0].isRadialDistortion?this.uvDistortion=e.distos[0]:(this.uvDistortion={C:new THREE.Vector2,R:new THREE.Vector4},this.uvDistortion.R.w=1/0)}setViewCamera(e){e.updateMatrixWorld(),this.E_prime.subVectors(e.position,this.textureCameraPosition).applyMatrix3(this.M_prime_Pre);var t=new s.Matrix4;t.copy(e.matrixWorldInverse),t.setPosition(0,0,0),t.premultiply(e.preProjectionMatrix),t.premultiply(e.postProjectionMatrix);var r=t.elements;this.viewProjectionScreenInverse.set(r[0],r[4],r[8],r[1],r[5],r[9],r[3],r[7],r[11]).invert();const n=(new s.Matrix3).set(2/this.uniforms.screenSize.value.x,0,-1,0,2/this.uniforms.screenSize.value.y,-1,0,0,1);this.viewProjectionScreenInverse.multiply(n)}setScreenSize(e,t){this.uniforms.screenSize.value.set(e,t)}}var Ve=Ue,Fe=r(9),Ie=r.n(Fe);s.ShaderChunk["postprocessing/radial"]=Ie.a;const He={uniforms:{tDiffuse:{value:null},center:{value:new s.Vector2(.5,.5)},resolution:{value:new s.Vector2(1,1)},pad:{value:2}},fragmentShader:"#version 300 es\nprecision highp float;\nprecision highp int;\n\n#include <postprocessing/radial>\n\nuniform sampler2D tDiffuse;\nuniform vec2 center;\nuniform vec2 resolution;\nuniform float pad;\n\nin vec2 vUv;\nout highp vec4 pc_fragColor;\n\nvoid main() {\n  vec2 uv = vUv;\n  fromRadial(center, resolution, pad, uv);\n  // discardOut(uv);\n  pc_fragColor = texture(tDiffuse, uv);\n  pc_fragColor.rgb -= 0.5;\n}"},Be={uniforms:{tDiffuse:{value:null},center:{value:new s.Vector2(.5,.5)},resolution:{value:new s.Vector2(1,1)},blur:{value:0},pad:{value:2}},fragmentShader:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D tDiffuse;\nuniform vec2 center;\nuniform vec2 resolution;\nuniform float blur;\nuniform float pad;\n\nin vec2 vUv;\nout highp vec4 pc_FragColor;\n\n#include <postprocessing/radial>\n\nvoid main() {\n  float t = max(0.01, blur*0.01);\n  vec2 p0 = mix(vUv,center,-t);\n  vec2 p1 = mix(vUv,center, t);\n  toRadial(center, resolution, pad, p0);\n  toRadial(center, resolution, pad, p1);\n  vec2 ddx = dFdx( vUv );\n  vec2 ddy = dFdy( vUv );\n  vec4 c0 = textureGrad(tDiffuse, p0, ddx, ddy);\n  vec4 c1 = textureGrad(tDiffuse, p1, ddx, ddy);\n  pc_FragColor = c1-c0;\n  pc_FragColor /= pc_FragColor.a;\n  pc_FragColor += 0.5;\n}"},Ye={uniforms:{tDiffuse:{value:null},center:{value:new s.Vector2(.5,.5)},resolution:{value:new s.Vector2(1,1)},stride:{value:1},amount:{value:1e6}},fragmentShader:"#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\nuniform float amount;\nuniform float stride;\n\nin vec2 vUv;\nout highp vec4 pc_fragColor;\n\nvoid main() {\n  vec3 step = vUv.y>0.5 ?\n  vec3(1./resolution.x,0.,vUv.x*resolution.x) :\n  vec3(0.,0.5/resolution.y,vUv.y*2.*resolution.y) ;\n  step.xy *= stride;\n  vec4 c0 = vec4(0.);\n  float imax = min(amount,step.z/stride);\n  for(float i=0.; i<imax; ++i)\n    c0 += textureGrad(tDiffuse, vUv - i * step.xy, vec2(0.), vec2(0.));\n  pc_fragColor = c0;\n\n}"};var Xe=r(10),qe=r.n(Xe);class We extends K{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof s.RawShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=s.UniformsUtils.clone(e.uniforms),this.material=new s.RawShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader||qe.a,fragmentShader:e.fragmentShader})),this.fsQuad=new J(this.material)}render(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}}])}));
//# sourceMappingURL=photogrammetric-camera.js.map