<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Photogrammetric Camera - Distortion</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" type="text/css" href="style/basic.css">
    </head>
    <body>
        <script src="../dist/three-photogrammetric-camera.js"></script>
        <script>
            // Three library
            var THREE = ThreePhotogrammetricCamera.THREE;
            // Photogrammetric camera
            var PhotogrammetricCamera = ThreePhotogrammetricCamera.PhotogrammetricCamera;
            // Parsers
            var MicmacOrientationParser = ThreePhotogrammetricCamera.MicmacOrientationParser;
            // Fetch files
            var FetchSource = ThreePhotogrammetricCamera.FetchSource;
            // Materials
            var ImageMaterial = ThreePhotogrammetricCamera.ImageMaterial;
            var imageVS = ThreePhotogrammetricCamera.imageVS;
            var imageFS = ThreePhotogrammetricCamera.imageFS;
        </script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/PLYLoader.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            /* ---------------------- Variables ---------------------- */
            var renderer;
            var width, height;
            var cameras, scene, controls;
            var prevCamera = new PhotogrammetricCamera();
            var viewCamera = new PhotogrammetricCamera();
            var nextCamera = new PhotogrammetricCamera();
            var textureCamera = new PhotogrammetricCamera();
            var textureMaterialUniforms = {}, viewMaterialUniforms = {};
            var wireMaterial, textureMaterial, viewMaterials = {};
            var textures = {};
            var environmentSphere, environmentPlane, pointclouds, meshes;
            var sphereRadius = 500, epsilonRadius = 100;
            var scenes;
            var todos = [], todoTimestamp = 0, duration = 0.3;

            viewCamera.zoom = 0.6;
            viewCamera.up.set(0, 0, 1);

            /* ------------------------- Main ------------------------ */
            init();
            var gui = initGUI();
            animate();

            /* ----------------------- Functions --------------------- */
            function init(){
                // HTML container for the rendering scene
                var container = document.createElement('div');
                document.body.appendChild(container);

                // Sizes
                width = window.innerWidth;
                height = window.innerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Materials
                wireMaterial = new THREE.MeshBasicMaterial({
                    color: 0x2194ce,
                    wireframe: true
                });

                var textureLoader = new THREE.TextureLoader();
                const uvTexture = textureLoader.load('data/uv.jpg');
                viewMaterialUniforms = {
                    map: uvTexture,
                    opacity: 1,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    vertexShader : imageVS,
                    fragmentShader : imageFS
                };
                textureMaterialUniforms = {
                    wireframe: false,
                    map: uvTexture,
                    size: 2,
                    sizeAttenuation: false,
                    vertexColors: THREE.VertexColors,
                    blending: THREE.NormalBlending,
                    transparent: true,
                    vertexShader : imageVS,
                    fragmentShader : imageFS
                };

                textureMaterial = new ImageMaterial(textureMaterialUniforms);
                textureMaterial.map = null;

                /* Main Scene ---------------------------------------- */
                // Cameras
                cameras = new THREE.Group();
                cameras.visible = false;

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                scene.add(viewCamera);
                scene.add(cameras);

                // Environment
                plane = new THREE.PlaneBufferGeometry(400, 400, 200, 200);
                environmentPlane = new THREE.Mesh(plane, textureMaterial);
                viewCamera.add(environmentPlane);

                environmentSphere = new THREE.Mesh(
                    new THREE.SphereBufferGeometry(-1, 1000, 1000), textureMaterial);
                environmentSphere.scale.set(sphereRadius, sphereRadius, sphereRadius);
		        environmentSphere.visible = false;
                viewCamera.add(environmentSphere);

                // Point clouds
                pointclouds = new THREE.Group();
                scene.add(pointclouds);

                // Meshes
                meshes = new THREE.Group();
                scene.add(meshes);

                // Ply loader for point clouds and meshes
                var plyLoader = new THREE.PLYLoader();
                var parsePly = (source) => (data => plyLoader.parse(data));

                // Available scenes
                scenes = {
                    Sample: function(){
                        clean();
                        var path = 'https://raw.githubusercontent.com/micmacIGN/Documentation/master/FilesSamples/';
                        var source = new FetchSource(path);
                        loadOrientation('Orientation-00.xml', source);
                    }
                };

                // Controls
                controls = new THREE.OrbitControls(viewCamera, renderer.domElement);
                controls.enableDamping = false;
                controls.screenSpacePanning = false;
                controls.maxPolarAngle = 0.75*Math.PI;

                // Event listeners
                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', keyDown, false);

                /* Callbacks ----------------------------------------- */
                function onWindowResize(){
                    width = window.innerWidth;
                    height = window.innerHeight;
                    const aspect = width/height;
                    renderer.setSize(width, height);
                    viewCamera.aspect = aspect;
                    viewCamera.updateMatrixWorld();
                    prevCamera.aspect = aspect;
                    prevCamera.updateMatrixWorld();
                    nextCamera.aspect = aspect;
                    nextCamera.updateMatrixWorld();
                }

                function keyDown(event){
                    switch(event.key){
                        case '+': textureMaterial.size++; break;
                        case '-': textureMaterial.size--; break;
                        case 'ArrowDown': setView(getCamera(nextCamera, -1));  break;
                        case 'ArrowUp': setView(getCamera(nextCamera, +1));  break;
                        case 'ArrowLeft': setTexture(getCamera(textureCamera, -1));  break;
                        case 'ArrowRight': setTexture(getCamera(textureCamera, +1));  break;
                        case 's': setCamera(getCamera(nextCamera, -1));  break;
                        case 'z': setCamera(getCamera(nextCamera, +1));  break;
                        case 't': setTexture(getCamera(nextCamera));  break;
                        case 'v': setView(getCamera(textureCamera));  break;
                        case 'c': console.log(nextCamera); break;
                        case 'p': console.log(viewCamera.position); break;
                        default : console.log(event.key, 'is not supported');
                    }
                }

                /* Loading ------------------------------------------- */
                function loadOrientation(name, source){
                    return source.open(name, 'text')
                    .then(parseOrientation(source))
                    .then(handleOrientation(name));
                }

                /* Parsing --------------------------------------------- */
                function parseOrientation(source){
                    var parsers = [MicmacOrientationParser];
                    return (data) => {
                        for(const parser of parsers) {
                            var parsed = parser.parse(data, source);
                            if (parsed) return parsed;
                        }
                        return undefined;
                    }
                }

                /* Handling ----------------------------------------- */
                function handleOrientation(name) {
                    return function(camera) {
                        if (!camera) return;
                        const match = name.match(/Orientation-(.*)\.[\w\d]*\.xml/i);
                        camera.name = match ? match[1] : name;
                        if (cameras.children.find(cam => cam.name == camera.name)) {
                            console.warn(`Camera "${camera.name}" was already loaded, skipping`);
                            return;
                        }
                        var check = '[?]';
                        if (camera.check) check = camera.check() ? '[Y]' : '[N]';
                        console.log(check, name);
                        camera.far = 15000;
                        camera.updateProjectionMatrix();
                        camera.add(cameraHelper(camera));
                        cameras.add(camera);
                        cameras.children.sort((a, b) => a.name.localeCompare(b.name));
                        setCamera(camera);
                        return camera;
                    };
                }

                /* Gets ---------------------------------------------- */
                function getCamera(camera, delta = 0){
                    const array = cameras.children;
                    const index = array.findIndex(cam => cam.name == camera.name);
                    return array[(index + delta + array.length) % array.length];
                }

                /* Sets ---------------------------------------------- */
                function setView(camera) {
                    if (!camera) return;
                    console.log('View:', camera.name);
                    prevCamera.set(viewCamera);
                    nextCamera.set(camera);
                    prevCamera.timestamp = 0;
                    nextCamera.zoom = viewCamera.zoom;
                    setMaterial(viewMaterials[camera.name], camera);
                    onWindowResize();
                    controls.enabled = false;
                    environmentPlane.position.x = 0;
                    environmentPlane.position.y = 0;
                    environmentPlane.position.z = -50;
                    environmentPlane.updateMatrixWorld();
                }

                function setTexture(camera) {
                    if (!camera) return;
                    console.log('Texture:', camera.name);
                    textureCamera = camera;
                    setMaterial(textureMaterial, camera);
                }

                function setCamera(camera){
                    setView(camera);
                    setTexture(camera);
                }

                function setMaterial(material, camera) {
                    material.map = textures[camera.name] || uvTexture;
                    material.setCamera(camera, camera);
                    material.needsUpdate = true;
                }

                /* Additional functions ------------------------------ */
                function cameraHelper(camera){
                    // Create the group (looking at intrinsic only) that
                    // should be added to the camera frame.
                    var group = new THREE.Group();

                    // Place a frustum
                    {
                        var m = new THREE.Matrix4().getInverse(camera.projectionMatrix);
                        var geometry = new THREE.BufferGeometry();
                        var vertices = new Float32Array(15);
                        // Get the 4 corners on the near plane (neglecting distortion
                        new THREE.Vector3(-1, -1, -1).applyMatrix4(m).toArray(vertices, 3);
                        new THREE.Vector3(-1,  1, -1).applyMatrix4(m).toArray(vertices, 6);
                        new THREE.Vector3( 1,  1, -1).applyMatrix4(m).toArray(vertices, 9);
                        new THREE.Vector3( 1, -1, -1).applyMatrix4(m).toArray(vertices, 12);
                        var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                        geometry.setIndex(indices);
                        geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
                        geometry.addGroup(0, 12, 0);
                        geometry.addGroup(12, 6, 1);

                        viewMaterials[camera.name] = new ImageMaterial(viewMaterialUniforms);
                        viewMaterials[camera.name].map = textures[camera.name] || uvTexture;

                        var mesh = new THREE.Mesh(geometry, [wireMaterial, viewMaterials[camera.name]]);
                        mesh.scale.set(100, 100, 100);
                        group.add(mesh);
                    }

                    // Place a sphere at the camera center
                    {
                        var geometry = new THREE.SphereBufferGeometry(0.03, 8, 8);
                        var material = new THREE.MeshBasicMaterial({color: 0xffff00});
                        group.add(new THREE.Mesh(geometry, material));
                    }
                    return group;
                }

                function clean(){
                    todos.length = 0;
                    const camera = new PhotogrammetricCamera();
                    prevCamera.set(camera);
                    viewCamera.set(camera);
                    nextCamera.set(camera);
                    textureCamera = viewCamera;
                    viewCamera.zoom = 0.8;
                    nextCamera.timestamp = undefined;
                    textureMaterial.map = null;
                    Object.keys(textures).forEach(key => textures[key].dispose());
                    while(cameras.children.length) cameras.remove(cameras.children[0]);
                    while(pointclouds.children.length) pointclouds.remove(pointclouds.children[0]);
                    while(meshes.children.length) meshes.remove(meshes.children[0]);
                    environmentPlane.position.z = -50;
                    controls.target.set(0, 0, 0);
                }
            }

            function initGUI(){
                var gui = new dat.GUI();
                
                // Updating functions
                function updateViewCameraFromGUI() {
                    viewCamera.updateProjectionMatrix();
                };

                // View camera
                var viewGUI = gui.addFolder('View Camera'); 
                viewGUI.add(viewCamera, 'zoom', 0, 2).listen().onChange(updateViewCameraFromGUI);
            }

            function render(){
                renderer.render(scene, viewCamera);
            }

            function animate(timestamp){
                requestAnimationFrame(animate);
                
                if (todos.length && timestamp > todoTimestamp){
                    todos.shift()();
                    todoTimestamp = timestamp + 200;
                }
                if (prevCamera.timestamp !== undefined) {
                    if (prevCamera.timestamp == 0) {
                        prevCamera.timestamp = timestamp;
                        nextCamera.timestamp = prevCamera.timestamp + 1000 * duration;
                    }
                    if (timestamp < nextCamera.timestamp) {
                      const t = 0.001 * (timestamp - prevCamera.timestamp) / duration;
                      viewCamera.set(prevCamera).lerp(nextCamera, t);
                    } else {
                      viewCamera.set(nextCamera);
                      prevCamera.timestamp = undefined;
                      nextCamera.timestamp = undefined;
                      controls.saveState();
                      controls.enabled = true;
                    }
                    viewCamera.near = 1;
                    viewCamera.far = 15000;
                    viewCamera.updateProjectionMatrix();
                }
                render();
            }
            scenes.Sample();
        </script>
    </body>
</html>
