<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Photogrammetric Camera - Distortion</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" type="text/css" href="style/basic.css">
    </head>
    <body>
        <script src="../dist/three-photogrammetric-camera.js"></script>
        <script>
            // Three library
            var THREE = ThreePhotogrammetricCamera.THREE;
            // Photogrammetric camera
            var PhotogrammetricCamera = ThreePhotogrammetricCamera.PhotogrammetricCamera;
            // Parsers
            var MicmacOrientationParser = ThreePhotogrammetricCamera.MicmacOrientationParser;
            // Fetch files
            var FetchSource = ThreePhotogrammetricCamera.FetchSource;
            // Materials
            var TextureMaterial = ThreePhotogrammetricCamera.TextureMaterial;
            var imagePointCloudVS = ThreePhotogrammetricCamera.imagePointCloudVS;
            var imageMeshVS = ThreePhotogrammetricCamera.imageMeshVS;
            var imageFS = ThreePhotogrammetricCamera.imageFS;
            var sceneVS = ThreePhotogrammetricCamera.sceneVS;
            var sceneFS = ThreePhotogrammetricCamera.sceneFS;
        </script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/PLYLoader.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            /* ---------------------- Variables ---------------------- */
            var renderer;
            var width, height;
            var cameras, scene, controls;
            var prevCamera = new PhotogrammetricCamera();
            var viewCamera = new PhotogrammetricCamera();
            var nextCamera = new PhotogrammetricCamera();
            var textureCamera = new PhotogrammetricCamera();
            var texturedScene;
            var rtScene, rtCamera, rtPlane;
            var textureMaterialUniforms = {}, viewMaterialUniforms = {};
            var wireMaterial, textureMaterial, viewMaterials = {}, sceneMaterial;
            var textures = {};
            var environmentSphere, environmentPlane, plane, pointclouds, meshes;
            var sphereRadius = 500, epsilonRadius = 100;
            var scenes;
            var todos = [], todoTimestamp = 0, duration = 0.3;
            var renderOptions = {method: 1};

            viewCamera.zoom = 0.06;
            viewCamera.up.set(0, 0, 1);

            /* ------------------------- Main ------------------------ */
            init();
            var gui = initGUI();
            animate();

            /* ----------------------- Functions --------------------- */
            function init(){
                // HTML container for the rendering scene
                var container = document.createElement('div');
                document.body.appendChild(container);

                // Sizes
                width = window.innerWidth;
                height = window.innerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Materials
                wireMaterial = new THREE.MeshBasicMaterial({
                    color: 0x2194ce,
                    wireframe: true
                });

                var textureLoader = new THREE.TextureLoader();
                const uvTexture = textureLoader.load('data/uv.jpg');
                viewMaterialUniforms = {
                    map: uvTexture,
                    opacity: 1,
                    transparent: true,
                    blending: THREE.NormalBlending,
                    vertexShader : imagePointCloudVS,
                    fragmentShader : imageFS
                };
                textureMaterialUniforms = {
                    wireframe: false,
                    map: uvTexture,
                    size: 2,
                    sizeAttenuation: false,
                    vertexColors: THREE.VertexColors,
                    blending: THREE.NormalBlending,
                    transparent: true,
                    vertexShader : imagePointCloudVS,
                    fragmentShader : imageFS,
                    textureExtrapol : true,
                    textureDisto : true,
                    viewExtrapol : true,
                    viewDisto : false,
                    debugOpacity : true
                };
                textureMaterial = new TextureMaterial(textureMaterialUniforms);
                textureMaterial.map = null;

                sceneMaterialUniforms = {
                    map: uvTexture,
                    vertexShader: sceneVS,
                    fragmentShader: sceneFS
                };
                sceneMaterial = new TextureMaterial(sceneMaterialUniforms);

                /* Main Scene ---------------------------------------- */
                // Cameras
                cameras = new THREE.Group();
                cameras.visible = false;

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                scene.add(viewCamera);
                scene.add(cameras);

                // Environment
                plane = new THREE.PlaneBufferGeometry(400, 400, 200, 200);
                plane.colors =  [new THREE.Color('red')];
                environmentPlane = new THREE.Mesh(plane, textureMaterial);
                //environmentPlane.colors =  [new THREE.Color('red')];
                //environmentPlane.scale.x = width/100; environmentPlane.scale.y = height/100;
                viewCamera.add(environmentPlane);

                environmentSphere = new THREE.Mesh(
                    new THREE.SphereBufferGeometry(-1, 1000, 1000), textureMaterial);
                environmentSphere.scale.set(sphereRadius, sphereRadius, sphereRadius);
		        environmentSphere.visible = false;
                viewCamera.add(environmentSphere);

                // Point clouds
                pointclouds = new THREE.Group();
                scene.add(pointclouds);

                // Meshes
                meshes = new THREE.Group();
                scene.add(meshes);

                var plyLoader = new THREE.PLYLoader();
                var parsePly = (source) => (data => plyLoader.parse(data));

                // Available scenes
                scenes = {
                    Sample: function(){
                        clean();
                        var path = 'https://raw.githubusercontent.com/micmacIGN/Documentation/master/FilesSamples/';
                        var source = new FetchSource(path);
                        loadOrientation('Orientation-00.xml', source);
                    },
                    Maurepas: function(){
                        clean();
                        //loadJSON('http://mathieu.bredif.free.fr/cors.php?url=data/maurepas/');
                        loadJSON('data/datasets/maurepas/');
                    },
                    Frejus: function(){
                        clean();
                        loadJSON('data/datasets/frejus/');
                    },
                    FrejusDisto: function(){
                        clean();
                        loadJSON('data/datasets/frejus_distorted/');

                    },
                    Pierrerue: function(){
                        clean();
                        loadJSON('data/datasets/pierrerue/');

                    },
                    Nanterre: function(){
                        clean();
                        loadJSON('data/datasets/nanterre_original/');
                    },
                };

                // Controls
                controls = new THREE.OrbitControls(viewCamera, renderer.domElement);
                controls.enableDamping = false;
                controls.screenSpacePanning = false;
                controls.maxPolarAngle = 0.75*Math.PI;

                // Event listeners
                window.addEventListener('resize', onWindowResize, false);
                window.addEventListener('keydown', keyDown, false);

                // Scene is textured
                texturedScene = new THREE.WebGLRenderTarget(width, height, {minFilter: THREE.LinearFilter,
                    magFilter: THREE.NearestFilter});

                /* Render to Texture Scene --------------------------- */
                // Camera
                rtCamera = new THREE.OrthographicCamera(width/-2, width/2, height/2, height/-2, 1, 1000);
                rtCamera.zoom = 1.3;

                // Scene
                rtScene = new THREE.Scene();

                // Material
                sceneMaterial.map = texturedScene.texture;

                // Plane to display the buffered textured scene
                rtPlane = new THREE.PlaneBufferGeometry(100, 100);
                rtDisplayImage = new THREE.Mesh(rtPlane, sceneMaterial);
                rtDisplayImage.position.z = -5;
                rtDisplayImage.scale.x = width/100;
				rtDisplayImage.scale.y = height/100;
                rtScene.add(rtDisplayImage);

                /* Callbacks ----------------------------------------- */
                function onWindowResize(){
                    width = window.innerWidth;
                    height = window.innerHeight;
                    const aspect = width/height;
                    renderer.setSize(width, height);
                    viewCamera.aspect = aspect;
                    viewCamera.updateMatrixWorld();
                    prevCamera.aspect = aspect;
                    prevCamera.updateMatrixWorld();
                    nextCamera.aspect = aspect;
                    nextCamera.updateMatrixWorld();
                }

                function keyDown(event){
                    switch(event.key){
                        case '+': textureMaterial.size++; break;
                        case '-': textureMaterial.size--; break;
                        case 'ArrowDown': setView(getCamera(nextCamera, -1));  break;
                        case 'ArrowUp': setView(getCamera(nextCamera, +1));  break;
                        case 'ArrowLeft': setTexture(getCamera(textureCamera, -1));  break;
                        case 'ArrowRight': setTexture(getCamera(textureCamera, +1));  break;
                        case 's': setCamera(getCamera(nextCamera, -1));  break;
                        case 'z': setCamera(getCamera(nextCamera, +1));  break;
                        case 't': setTexture(getCamera(nextCamera));  break;
                        case 'v': setView(getCamera(textureCamera));  break;
                        case 'c': console.log(nextCamera); break;
                        case 'p': console.log(viewCamera.position); break;
                        default : console.log(event.key, 'is not supported');
                    }
                }

                /* Loading ------------------------------------------- */
                function loadOrientation(name, source){
                    return source.open(name, 'text')
                    .then(parseOrientation(source))
                    .then(handleOrientation(name));
                }

                function loadImage(url, source){
                    return source.open(url, 'dataURL')
                    .then(parseImage(source))
                    .then(handleImage(url));
                }

                function loadOrientedImage(orientationUrl, imageUrl, source){
                    loadImage(imageUrl, source).then(() => loadOrientation(orientationUrl, source));
                }

                function loadPlyPC(url, source){
                    return source.open(url, 'arrayBuffer')
                    .then(parsePly(source))
                    .then(handlePointCloud(url));
                }

                function loadPlyMesh(url, source){
                    return source.open(url, 'arrayBuffer')
                    .then(parsePly(source))
                    .then(handleMesh(url));
                }

                function loadJSON(path, file){
                    file = file || 'index.json';
                    var source = new FetchSource(path);
                    source.open(file, 'text').then((json)=> {
                        json = JSON.parse(json);
                        if(json.plane && json.plane.position){
                            const position = json.plane.position;
                            if (position.x !== undefined) environmentPlane.position.x = position.x;
                            if (position.y !== undefined) environmentPlane.position.y = position.y;
                            if (position.z !== undefined) environmentPlane.position.z = position.z;
                            controls.target.copy(environmentPlane.position);
                            const scale = json.plane.scale || 1000;
                        }
                        if(json.sphere){
                            sphereRadius = json.sphere.radius;
                            if(sphereRadius != undefined){
                                environmentSphere.scale.set(sphereRadius, sphereRadius, sphereRadius);
                            }
                        }
                        if(json.target){
                            controls.target.copy(json.target);
                        }
                        json.pc.forEach(url => todos.push(() => loadPlyPC(url, source)));
                        json.mesh.forEach(url => todos.push(() => loadPlyMesh(url, source)));
                        json.ori.forEach((orientationUrl, i) => todos.push(() =>
                            loadOrientedImage(orientationUrl, json.img[i], source)));
                    });
                }

                /* Parsing --------------------------------------------- */
                function parseOrientation(source){
                    var parsers = [MicmacOrientationParser];
                    return (data) => {
                        for(const parser of parsers) {
                            var parsed = parser.parse(data, source);
                            if (parsed) return parsed;
                        }
                        return undefined;
                    }
                }

                function parseImage(source){
                    return (data) => {
                        return new Promise((resolve, reject) => {
                            textureLoader.load(data, resolve, undefined, reject)
                        }).finally(() => source.close(data, 'dataURL'));
                    }
                }

                /* Handeling ----------------------------------------- */
                function handleOrientation(name) {
                    return function(camera) {
                        if (!camera) return;
                        const match = name.match(/Orientation-(.*)\.[\w\d]*\.xml/i);
                        camera.name = match ? match[1] : name;
                        if (cameras.children.find(cam => cam.name == camera.name)) {
                            console.warn(`Camera "${camera.name}" was already loaded, skipping`);
                            return;
                        }
                        var check = '[?]';
                        if (camera.check) check = camera.check() ? '[Y]' : '[N]';
                        console.log(check, name);
                        camera.far = 15000;
                        camera.updateProjectionMatrix();
                        camera.add(cameraHelper(camera));
                        cameras.add(camera);
                        cameras.children.sort((a, b) => a.name.localeCompare(b.name));
                        setCamera(camera);
                        return camera;
                    };
                }

                function handleImage(name) {
                    return function(texture) {
                        if (!texture) return;
                        const match = name.match(/([^\/]*)\.[\w\d]/i);
                        texture.name = match ? match[1] : name;
                        textures[texture.name] = texture;
                        const camera = cameras.getObjectByName(texture.name);
                        setCamera(camera);
                        return texture;
                    };
                }

                function handlePointCloud(name){
                    return function(geometry){
                        // Show the name of the file to be loaded
                        console.log(name);
                        // Create the point cloud
                        var points = new THREE.Points(geometry, textureMaterial);
                        pointclouds.add(points);
                        // Find center of the geometry
                        geometry.computeBoundingBox();
                        var center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        points.updateMatrixWorld(true);
                    }
                }

                function handleMesh(name){
                    return function(geometry){
                        // Show the name of the file to be loaded
                        console.log(name);
                        // Create the mesh
                        geometry.computeVertexNormals();
                        var mesh = new THREE.Mesh(geometry, textureMaterial);
                        meshes.add(mesh);
                        // Find center of the geometry
                        geometry.computeBoundingBox();
                        var center = new THREE.Vector3();
                        geometry.boundingBox.getCenter(center);
                        mesh.updateMatrixWorld(true);
                    }
                }


                /* Sets ---------------------------------------------- */
                function setView(camera) {
                    if (!camera) return;
                    console.log('View:', camera.name);
                    prevCamera.set(viewCamera);
                    nextCamera.set(camera);
                    prevCamera.timestamp = 0;
                    nextCamera.zoom = viewCamera.zoom;
                    setMaterial(viewMaterials[camera.name], camera);
                    onWindowResize();
                    controls.enabled = false;

                    environmentPlane.position.x = 0;
                    environmentPlane.position.y = 0;
                    environmentPlane.position.z = -50;
                    environmentPlane.updateMatrixWorld();
                }

                function setTexture(camera) {
                    if (!camera) return;
                    console.log('Texture:', camera.name);
                    textureCamera = camera;
                    setMaterial(textureMaterial, camera);
	            textureMaterial.r2max = textureMaterial.uvDistortion.R.w;
                }

                function setCamera(camera){
                    setView(camera);
                    setTexture(camera);
                }

                function setMaterial(material, camera) {
                    material.map = textures[camera.name] || uvTexture;
                    material.setCamera(camera, camera);
                    if(renderOptions.method == 1) material.vertexShader = imagePointCloudVS;
                    else material.vertexShader = imageMeshVS;
                    material.needsUpdate = true;
                }

                /* Gets ---------------------------------------------- */
                function getCamera(camera, delta = 0){
                    const array = cameras.children;
                    const index = array.findIndex(cam => cam.name == camera.name);
                    return array[(index + delta + array.length) % array.length];
                }

                /* Additional functions ------------------------------ */
                function cameraHelper(camera){
                    // Create the group (looking at intrinsic only) that
                    // should be added to the camera frame.
                    var group = new THREE.Group();

                    // Place a frustum
                    {
                        var m = new THREE.Matrix4().getInverse(camera.projectionMatrix);
                        var geometry = new THREE.BufferGeometry();
                        var vertices = new Float32Array(15);
                        // Get the 4 corners on the near plane (neglecting distortion
                        new THREE.Vector3(-1, -1, -1).applyMatrix4(m).toArray(vertices, 3);
                        new THREE.Vector3(-1,  1, -1).applyMatrix4(m).toArray(vertices, 6);
                        new THREE.Vector3( 1,  1, -1).applyMatrix4(m).toArray(vertices, 9);
                        new THREE.Vector3( 1, -1, -1).applyMatrix4(m).toArray(vertices, 12);
                        var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                        geometry.setIndex(indices);
                        geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
                        geometry.addGroup(0, 12, 0);
                        geometry.addGroup(12, 6, 1);

                        viewMaterials[camera.name] = new TextureMaterial(viewMaterialUniforms);
                        viewMaterials[camera.name].map = textures[camera.name] || uvTexture;

                        var mesh = new THREE.Mesh(geometry, [wireMaterial, viewMaterials[camera.name]]);
                        mesh.scale.set(100, 100, 100);
                        group.add(mesh);
                    }

                    // Place a sphere at the camera center
                    {
                        var geometry = new THREE.SphereBufferGeometry(0.03, 8, 8);
                        var material = new THREE.MeshBasicMaterial({color: 0xffff00});
                        group.add(new THREE.Mesh(geometry, material));
                    }
                    return group;
                }

                function clean(){
                    todos.length = 0;
                    const camera = new PhotogrammetricCamera();
                    prevCamera.set(camera);
                    viewCamera.set(camera);
                    nextCamera.set(camera);
                    textureCamera = viewCamera;
                    viewCamera.zoom = 0.06;
                    nextCamera.timestamp = undefined;
                    textureMaterial.map = null;
                    Object.keys(textures).forEach(key => textures[key].dispose());
                    while(cameras.children.length) cameras.remove(cameras.children[0]);
                    while(pointclouds.children.length) pointclouds.remove(pointclouds.children[0]);
                    while(meshes.children.length) meshes.remove(meshes.children[0]);
                    environmentPlane.position.z = -50;
                    controls.target.set(0, 0, 0);
                }
            }

            function initGUI(){
                var gui = new dat.GUI();

                // Selection of rendering method
                function updateRenderingFromGUI(){
                    if(renderOptions.method == 1) textureMaterial.vertexShader = imagePointCloudVS;
                    else textureMaterial.vertexShader = imageMeshVS;
                    textureMaterial.needsUpdate = true;
                }

                gui.add(renderOptions, 'method', {Single: 1, Double: 2}).name('rendering method')
                .listen().onChange(updateRenderingFromGUI);

                // Scene options
                var scenesGUI = gui.addFolder('Scenes');
                for(const key in scenes) scenesGUI.add(scenes, key);
                scenesGUI.closed = false;

                // Camera options
                function updateViewCameraFromGUI() {
                    viewCamera.updateProjectionMatrix();
                };

                function updateTextureCameraFromGUI() {
                    textureCamera.updateProjectionMatrix();
                };

                function updatesceneInfoFromGUI(){
                    sceneMaterial.viewDisto = textureMaterial.viewDisto;
                    sceneMaterial.viewExtrapol = textureMaterial.viewExtrapol;
                    sceneMaterial.debugOpacity = textureMaterial.debugOpacity;
                }
                function updateRmaxFromGUI(value) {
                    textureMaterial.uvDistortion.R.w = value * value * textureMaterial.r2max;
                };

		        var param = { rmax: 1 };
                var textureGUI = gui.addFolder('Texture Camera'); // Texture
                textureGUI.add(textureMaterial, 'textureDisto').name('apply distortion');
                textureGUI.add(textureMaterial, 'textureExtrapol').name('apply extrapol');
                textureGUI.add(param, 'rmax', 0, 1).name('rmax ratio').onChange(updateRmaxFromGUI);

                var viewGUI = gui.addFolder('View Camera'); // View
                //viewGUI.add(cameras, 'visible');
                viewGUI.add(viewCamera, 'zoom', 0, 2).listen().onChange(updateViewCameraFromGUI);
                viewGUI.add(textureMaterial, 'viewDisto').name('apply distortion')
                    .listen().onChange(updatesceneInfoFromGUI);
                viewGUI.add(textureMaterial, 'viewExtrapol').name('apply extrapol')
                .listen().onChange(updatesceneInfoFromGUI);

                // Debug Options
                var debugGUI = gui.addFolder('Debug')
                debugGUI.add(textureMaterial, 'debugOpacity', 0, 1)
                .listen().onChange(updatesceneInfoFromGUI);
                debugGUI.add(textureMaterial, 'wireframe');
                debugGUI.add(environmentSphere, 'visible').name('sphere');
                debugGUI.add(environmentPlane, 'visible').name('plane');
                debugGUI.add(pointclouds, 'visible').name('pointcloud');
                debugGUI.add(meshes, 'visible').name('mesh');
            }

            function render(){
                if(renderOptions.method == 2){
                    // Render onto our off screen texture
                    renderer.render(scene, viewCamera, texturedScene);
                    // Finally, draw to the screen
                    renderer.render(rtScene, rtCamera);
                }else{
                    renderer.render(scene, viewCamera);
                }
            }

            function animate(timestamp){
                requestAnimationFrame(animate);
                if (todos.length && timestamp > todoTimestamp){
                    todos.shift()();
                    todoTimestamp = timestamp + 200;
                }

                if (prevCamera.timestamp !== undefined) {
                    if (prevCamera.timestamp == 0) {
                        prevCamera.timestamp = timestamp;
                        nextCamera.timestamp = prevCamera.timestamp + 1000 * duration;
                    }
                    if (timestamp < nextCamera.timestamp) {
                      const t = 0.001 * (timestamp - prevCamera.timestamp) / duration;
                      viewCamera.set(prevCamera).lerp(nextCamera, t);
                    } else {
                      viewCamera.set(nextCamera);
                      prevCamera.timestamp = undefined;
                      nextCamera.timestamp = undefined;
                      controls.saveState();
                      controls.enabled = true;
                    }
                    viewCamera.near = 1;
                    viewCamera.far = 15000;
                    viewCamera.updateProjectionMatrix();
                }
                if (viewMaterials[nextCamera.name])
                    viewMaterials[nextCamera.name].setValues(viewMaterialUniforms);

                // Material update
                textureMaterial.setCamera(textureCamera, viewCamera);
                sceneMaterial.setCamera(textureCamera, viewCamera);
                render();
            }

            scenes.Maurepas();
        </script>
    </body>
</html>
