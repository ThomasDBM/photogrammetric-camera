<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Photogrammetric Camera - Distortion</title>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" type="text/css" href="style/basic.css">
    </head>
    <body>
        <script src="../dist/three-photogrammetric-camera.js"></script>
        <script>
            // Three library
            var THREE = ThreePhotogrammetricCamera.THREE;
            // Photogrammetric camera
            var PhotogrammetricCamera = ThreePhotogrammetricCamera.PhotogrammetricCamera;
            // Parsers
            var MicmacOrientationParser = ThreePhotogrammetricCamera.MicmacOrientationParser;
            // Fetch files
            var FetchSource = ThreePhotogrammetricCamera.FetchSource;
            // Materials
            var TextureMaterial = ThreePhotogrammetricCamera.TextureMaterial;
            var imagePointCloudVS = ThreePhotogrammetricCamera.imagePointCloudVS;
            var imageMeshVS = ThreePhotogrammetricCamera.imageMeshVS;
            var imageFS = ThreePhotogrammetricCamera.imageFS;
            var sceneVS = ThreePhotogrammetricCamera.sceneVS;
            var sceneFS = ThreePhotogrammetricCamera.sceneFS;
        </script>
        <script src="js/dat.gui.min.js"></script>
        <script src="js/PLYLoader.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            /* ---------------------- Variables ---------------------- */
            var renderer;
            var width, height;
            var cameras, scene, controls;
            var prevCamera = new PhotogrammetricCamera();
            var viewCamera = new PhotogrammetricCamera();
            var nextCamera = new PhotogrammetricCamera();
            var textureCamera = new PhotogrammetricCamera();
            var texturedScene;
            var rtScene, rtCamera, rtPlane;
            var textureMaterialUniforms = {}, viewMaterialUniforms = {};
            var wireMaterial, textureMaterial, viewMaterials = {}, sceneMaterial;
            var textures = {};
            var environmentSphere, environmentPlane, plane, pointclouds, meshes;
            var sphereRadius = 500, epsilonRadius = 100;
            var scenes;
            var todos = [], todoTimestamp = 0, duration = 0.3;
            var param = { method: 1, rmax: 1 };
            var geometry;

            var plane;

            viewCamera.zoom = 0.8;
            viewCamera.up.set(0, 0, 1);

            /* ------------------------- Main ------------------------ */
            init();
            //var gui = initGUI();
            animate();

            /* ----------------------- Shaders ----------------------- */

            function vertexShader() {
                return `
                    varying highp vec3 vPosition;

                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
                    }
                `
            }

            function fragmentShader() {
                return `
                    varying highp vec3 vPosition;
                    uniform sampler2D map;
                    uniform mat4 modelMatrix;
                    uniform vec3 uvwTexturePosition;
                    uniform mat4 uvwTexturePreTrans;
                    uniform mat4 uvwTexturePostTrans;

                    void main() {
                        mat4 m = modelMatrix;
                        m[3].xyz -= uvwTexturePosition;
                        vec4 uvw = uvwTexturePreTrans * m * vec4(vPosition, 1.);

                        if( uvw.w > 0.){
                            uvw = uvwTexturePostTrans*uvw;
                            uvw.xyz /= 2. * uvw.w;
                            uvw.xyz += vec3(0.5);
                            vec3 border = min(uvw.xyz, 1. - uvw.xyz);

                            if (all(greaterThan(border,vec3(0.)))){
                                vec4 color = texture2D(map, uvw.xy);
                                gl_FragColor = color;
                            }else discard;
                        }

                        
                    }
                `
            }

            /* ----------------------- Functions --------------------- */
            function init(){
                // HTML container for the rendering scene
                var container = document.createElement('div');
                document.body.appendChild(container);

                // Sizes
                width = window.innerWidth;
                height = window.innerHeight;

                // Renderer
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Cameras
                cameras = new THREE.Group();
                cameras.visible = false;

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                scene.add(textureCamera);

                // Material
                var textureLoader = new THREE.TextureLoader();
                const uvTexture = textureLoader.load('data/uv.jpg');

                var uniforms = {
                    //wireframe: true,
                    map: uvTexture,
                    vertexShader: vertexShader(),
                    fragmentShader: fragmentShader()
                };
                textureMaterial =  new TextureMaterial(uniforms);
                geometry = new THREE.PlaneBufferGeometry(10, 10, 4, 4);
                plane = new THREE.Mesh(geometry, textureMaterial);
                textureCamera.add(plane);

                var path = 'https://raw.githubusercontent.com/micmacIGN/Documentation/master/FilesSamples/';
                var source = new FetchSource(path);
                loadOrientation('Orientation-00.xml', source);

                /* Loading ------------------------------------------- */
                function loadOrientation(name, source){
                    return source.open(name, 'text')
                    .then(parseOrientation(source))
                    .then(handleOrientation(name));
                }

                /* Parsing --------------------------------------------- */
                function parseOrientation(source){
                    var parsers = [MicmacOrientationParser];
                    return (data) => {
                        for(const parser of parsers) {
                            var parsed = parser.parse(data, source);
                            if (parsed) return parsed;
                        }
                        return undefined;
                    }
                }

                /* Handling ----------------------------------------- */
                function handleOrientation(name) {
                    return function(camera) {
                        if (!camera) return;
                        const match = name.match(/Orientation-(.*)\.[\w\d]*\.xml/i);
                        camera.name = match ? match[1] : name;
                        if (cameras.children.find(cam => cam.name == camera.name)) {
                            console.warn(`Camera "${camera.name}" was already loaded, skipping`);
                            return;
                        }
                        var check = '[?]';
                        if (camera.check) check = camera.check() ? '[Y]' : '[N]';
                        console.log(check, name);
                        camera.far = 15000;
                        camera.updateProjectionMatrix();
                        cameras.add(camera);
                        cameras.children.sort((a, b) => a.name.localeCompare(b.name));
                        setCamera(camera);
                        return camera;
                    };
                }

                /* Sets --------------------------------------------- */
                function setCamera(camera){
                    if (!camera) return;
                    console.log('Texture:', camera.name);
                    var fixedPosition = new THREE.Vector3(0, 0, 10);
                    textureCamera = camera;
                    setMaterial(textureMaterial, camera);
                    plane.position.subVectors(textureCamera.position, fixedPosition);
                }

                function setMaterial(material, camera) {
                    const pre = new THREE.Matrix4().copy(camera.preProjectionMatrix).multiply(camera.matrixWorldInverse);
                    const post = new THREE.Matrix4().copy(camera.postProjectionMatrix);
                    var lut = [];
                    var positions = geometry.attributes.position.array;
                    for ( var n=0; n<positions.length; n=n+3) {
                        var position = new THREE.Vector4(positions[n], positions[n+1], positions[n+2], 1);
                        var uvw = position;
                        //uvw = position.applyMatrix4(pre);
                        //uvw = position.applyMatrix4(post);
                        
                        //uvw.xyz/= 2.uvw.w;
                        //uvw.xyz += vec3(0.5);
                        lut.push(uvw);
                    }
                    textureMaterial.setCamera(camera, camera);
                }
            }

            function animate(timestamp){
                requestAnimationFrame(animate);
                renderer.render(scene, textureCamera);
            }
        </script>
    </body>
</html>