<!DOCTYPE html>
<html lang="en">
  <head>
    <title>radial image</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            overflow: hidden;
            margin: 0;
        }
        #help {
          margin: 20px;
        }
    </style>
  </head>
  <body>
    <!--<script src="http://mrdoob.github.io/stats.js/build/stats.min.js"></script>!-->
    <script src="../dist/photogrammetric-camera.js"></script>
    <script>
      var THREE = PhotogrammetricCamera.THREE;
      var THREE_ = PhotogrammetricCamera.THREE_;

      let camera, renderer, composer;
      let object, radialEffect, animated;
      let radialSumEffect = [];
      //let stats;

      init();
      animate();

      function init() {
  			if ( THREE_.WEBGL.isWebGL2Available() === false ) {
  				document.body.appendChild( THREE_.WEBGL.getWebGL2ErrorMessage() );
  			}
        animated = true;
        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 400;

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0x0000ff, 1, 1000 );
        scene.background = new THREE.Color( 0x000011 );

        object = new THREE.Object3D();
        scene.add( object );

        const geometry = new THREE.SphereGeometry( 1, 4, 4 );
        const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );

        for ( let i = 0; i < 100; i ++ ) {

          const mesh = new THREE.Mesh( geometry, material );
          mesh.position.set( Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5 ).normalize();
          mesh.position.multiplyScalar( Math.random() * 400 );
          mesh.rotation.set( Math.random() * 2, Math.random() * 2, Math.random() * 2 );
          mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 50;
          object.add( mesh );

        }

        scene.add( new THREE.AmbientLight( 0x222222 ) );

        const light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        // postprocessing

        const renderTarget = new THREE.WebGLRenderTarget(1,1,{
           minFilter: THREE.LinearFilter,
           magFilter: THREE.LinearFilter,
           type:THREE.FloatType
         });
        //renderTarget.texture.internalFormat ="RGBA32I";
        //renderTarget.texture.format = THREE.RGBAIntegerFormat;
        //renderTarget.texture.type =THREE.IntType;

        composer = new THREE_.EffectComposer( renderer, renderTarget );
        composer.setSize( window.innerWidth, 2.*window.innerHeight );
        composer.addPass( new THREE_.RenderPass( scene, camera ) );

        radialEffect = new PhotogrammetricCamera.RawShaderPass( PhotogrammetricCamera.RadialShader );
        //radialEffect.material.defines.HORIZONTAL ='';
        composer.addPass( radialEffect );

        var amount = 6, stride = 1;
        for(let i = 0; i < 10; ++i ) {
          radialSumEffect[i] = new PhotogrammetricCamera.RawShaderPass( PhotogrammetricCamera.SumShader );
          radialSumEffect[i].uniforms.stride.value = stride;
          radialSumEffect[i].uniforms.amount.value = amount;
          //radialSumEffect[i].material.defines.HORIZONTAL ='';
  				composer.addPass( radialSumEffect[i] );
          stride *= amount;
        }

        radialBlurEffect = new PhotogrammetricCamera.RawShaderPass( PhotogrammetricCamera.RadialBlurShader );
        //radialBlurEffect.material.defines.HORIZONTAL ='';
        composer.addPass( radialBlurEffect );

        window.addEventListener( 'resize', onWindowResize );
        window.addEventListener( 'mousemove', onMouseMove );
        window.addEventListener( 'click', onClick );
        window.addEventListener( 'keydown', onKeyDown );
        onWindowResize();


        //stats = new Stats();
        //stats.showPanel( 0 ); // 0: fps, 1: ms, 2: mb, 3+: custom
        //document.body.appendChild( stats.dom );
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();


        const pad = 10;
        renderer.setSize( window.innerWidth, window.innerHeight );
        composer.setSize( window.innerWidth+2*pad, 2.*window.innerHeight + 4*pad);
        const w = window.innerWidth * window.devicePixelRatio;
        const h = window.innerHeight * window.devicePixelRatio;
        const s = Math.max(w,h);
        let enabled = radialSumEffect[0].enabled;
        for(var i = 0; i<radialSumEffect.length; ++i) {
          const u = radialSumEffect[i].uniforms;
          u.resolution.value.set(w+2*pad*window.devicePixelRatio,h+2*pad*window.devicePixelRatio);
          radialSumEffect[i].enabled = enabled;
          enabled = enabled && ((u.stride.value * u.amount.value) < s);
        }
        //console.log(window.devicePixelRatio);
				radialEffect.uniforms.resolution.value.set(w,h);
				radialBlurEffect.uniforms.resolution.value.set(w,h);
				radialEffect.uniforms.pad.value = pad;
				radialBlurEffect.uniforms.pad.value = pad;

      }

      function setCenter(x,y) {
        radialEffect.uniforms.center.value.set(x,y);
        radialBlurEffect.uniforms.center.value.set(x,y);
      }

      function moveCenter(dx,dy) {
        const x = radialEffect.uniforms.center.value.x + dx;
        const y = radialEffect.uniforms.center.value.y + dy;
        setCenter(x,y);
      }

      function onMouseMove(e) {
        let x = e.clientX/window.innerWidth;
        let y = 1-e.clientY/window.innerHeight;
        setCenter(x,y);
      }

      function moveAmount(delta) {
        let amount = Math.max(0,radialBlurEffect.uniforms.amount.value + delta);
        radialBlurEffect.uniforms.amount.value = amount;
      }

      function onClick(e) {
        const enabled = !radialBlurEffect.enabled;
				radialBlurEffect.enabled = enabled;
        radialEffect.enabled = enabled;
        radialSumEffect[0].enabled = enabled;
        onWindowResize();
      }

      function onKeyDown(e) {
        if (event.defaultPrevented) return;

        const speed = 10;
        switch (event.key) {
          case "ArrowDown" : moveCenter(0,-speed/window.innerHeight); break;
          case "ArrowUp"   : moveCenter(0, speed/window.innerHeight); break;
          case "ArrowLeft" : moveCenter(-speed/window.innerWidth,0); break;
          case "ArrowRight": moveCenter(speed/window.innerWidth,0); break;
          case "Enter"     : onClick(); break;
          case " "         : animated = !animated; break;
          case "+"         : moveAmount(+1); break;
          case "-"         : moveAmount(-1); break;
          default          : return;
        }
        event.preventDefault();
      }

      function animate() {

        //stats.begin();
        if(animated) {
          object.rotation.x += 0.005;
          object.rotation.y += 0.01;
        }

        composer.render();
	      //stats.end();
        requestAnimationFrame( animate );

      }

    </script>

  </body>
</html>
